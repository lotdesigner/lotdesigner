<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lot Layout Designer â€” Free Property & Site Plan Drawing Tool</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Free browser-based CAD tool for drawing lot layouts and site plans. Draw to scale, measure distances and areas, snap to points, and export to SVG. No install required.">
    <meta name="keywords" content="lot layout designer, site plan drawing, free CAD tool, lot plan tool, property boundary drawing, site plan CAD, free lot design, online CAD, land plot designer, parcel mapping tool">
    <meta name="author" content="Lot Layout Designer">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://lotdesigner.github.io/lotdesigner/">

    <!-- Open Graph (Facebook, LinkedIn previews) -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Lot Layout Designer â€” Free Property & Site Plan Drawing Tool">
    <meta property="og:description" content="Free browser-based CAD tool for drawing lot layouts and site plans. Draw to scale, measure distances and areas, snap to points, and export to SVG. No install required.">
    <meta property="og:url" content="https://lotdesigner.github.io/lotdesigner/">
    <meta property="og:image" content="https://lotdesigner.github.io/lotdesigner/preview.png">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Lot Layout Designer â€” Free Property & Site Plan Drawing Tool">
    <meta name="twitter:description" content="Free browser-based CAD tool for drawing lot layouts and site plans. Draw to scale, measure distances and areas, snap to points, and export to SVG.">
    <meta name="twitter:image" content="https://lotdesigner.github.io/lotdesigner/preview.png">
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "Lot Layout Designer",
      "description": "Free browser-based CAD tool for drawing lot layouts and site plans. Draw to scale, measure distances and areas, snap to points, and export to SVG or PDF.",
      "applicationCategory": "DesignApplication",
      "applicationSubCategory": "CAD / Survey Tool",
      "operatingSystem": "Any (Web Browser)",
      "url": "https://lotdesigner.github.io/lotdesigner/",
      "featureList": [
        "Draw property boundaries and lot lines to scale",
        "Measure distances and areas",
        "Snap-to-point and snap-to-line precision",
        "Polygon area calculation",
        "Export to SVG",
        "Scale calibration",
        "Multi-layer drawing",
        "No installation required"
      ],
      "offers": { "@type": "Offer", "price": "0", "priceCurrency": "USD" }
    }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');

        * { box-sizing: border-box; }
        :root {
            --chrome-dark:   #2e3a4e;   /* top/bottom bar */
            --chrome-mid:    #3d4f66;   /* top bar hover, dividers */
            --chrome-light:  #e4e8ed;   /* sidebar bg */
            --chrome-border: #b8c0ca;   /* sidebar borders */
            --panel-bg:      #f0f2f4;   /* section bg */
            --btn-bg:        #ffffff;   /* button face */
            --btn-border:    #a8b0ba;   /* button border */
            --btn-hover:     #e8edf2;   /* button hover */
            --blue-active:   #1a5fa0;   /* active/selected accent */
            --blue-light:    #d0e4f5;   /* active bg tint */
            --blue-label:    #1e4a80;   /* section label color */
            --text-dark:     #1a2535;   /* primary text */
            --text-mid:      #3d4f66;   /* secondary text */
            --text-muted:    #6a7888;   /* muted text */
            --canvas-bg:     #f8f6f0;   /* drafting paper tint */
            --scale-gold:    #a07820;   /* scale accent */
            --scale-bg:      #fffbf0;   /* scale input bg */
            --scale-border:  #c9a830;   /* scale border */
            --danger-bg:     #fbeaea;
            --danger-border: #c84040;
            --danger-text:   #8b1a1a;
            --green-active:  #1a6a2a;   /* kept for boundary layer active */
        }
        body { margin: 0; font-family: 'Inter', Arial, sans-serif; overflow: hidden; background: var(--chrome-dark); }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           TOP WORKFLOW BAR
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #topBar {
            position: fixed; top: 0; left: 0; right: 0; height: 48px;
            background: var(--chrome-dark);
            border-bottom: 2px solid #1a2535;
            display: flex; align-items: center; gap: 0;
            z-index: 1100; padding: 0 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.35);
        }
        #appTitle {
            font-size: 13px; font-weight: 600; color: #9bb8d8;
            white-space: nowrap; margin-right: 14px; letter-spacing: 0.6px;
            font-family: 'Courier New', monospace;
            display: flex; align-items: center;
        }
        #workflowSteps {
            display: flex; gap: 2px; flex: 1;
        }
        .wf-step {
            display: flex; align-items: center; gap: 5px;
            padding: 5px 11px; border-radius: 4px; cursor: pointer;
            border: 1px solid transparent; font-size: 11px; color: #8aa8c4;
            background: none; transition: all 0.15s; white-space: nowrap;
        }
        .wf-step:hover { background: var(--chrome-mid); color: #ccdcec; border-color: #4a6080; }
        .wf-step.wf-active { background: var(--blue-active); color: #e8f2ff; border-color: #4a90d0; box-shadow: inset 0 1px 0 rgba(255,255,255,0.15); }
        .wf-step .wf-num {
            width: 18px; height: 18px; border-radius: 50%;
            background: rgba(255,255,255,0.12); color: #8aa8c4; font-size: 10px; font-weight: 600;
            display: flex; align-items: center; justify-content: center; flex-shrink: 0;
        }
        .wf-step.wf-active .wf-num { background: rgba(255,255,255,0.25); color: #ffffff; }
        .wf-step .wf-ico { font-size: 13px; }
        .wf-step .wf-lbl { font-size: 11px; font-weight: 500; }

        /* Top right â€” file/export actions */
        #topRight {
            display: flex; align-items: center; gap: 3px; margin-left: 10px;
            padding-left: 10px; border-left: 1px solid #3d4f66;
        }
        .top-action-btn {
            background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.18);
            color: #b8ccdd; border-radius: 3px; padding: 4px 9px; cursor: pointer;
            font-size: 11px; font-weight: 500; white-space: nowrap; display: flex; align-items: center; gap: 4px;
            transition: all 0.12s;
        }
        .top-action-btn:hover { background: rgba(255,255,255,0.16); color: #e0ecf8; border-color: rgba(255,255,255,0.3); }
        .top-action-btn.danger { border-color: rgba(200,80,80,0.4); color: #f0a0a0; }
        .top-action-btn.danger:hover { background: rgba(180,40,40,0.3); }
        .top-sep { width: 1px; height: 22px; background: #3d4f66; margin: 0 4px; }
        #autosaveIndicator { font-size: 9px; color: #5a7090; white-space: nowrap; padding: 0 6px; }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           DISCLAIMER â€” floating box over canvas
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #disclaimerBar {
            position: fixed;
            top: 56px;          /* just below the top bar with a small gap */
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,245,245,0.97);
            border: 1px solid #c87070;
            border-radius: 5px;
            padding: 4px 14px;
            z-index: 1080;
            pointer-events: none;
            font-size: 9.5px; color: #8a3535; font-style: italic;
            box-shadow: 0 2px 8px rgba(140,40,40,0.18);
            white-space: nowrap;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SIDEBAR
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #toolbar {
            position: fixed; top: 48px; left: 0;
            width: 196px; height: calc(100vh - 48px - 44px);
            background: var(--chrome-light); color: var(--text-dark);
            z-index: 1000; overflow-y: auto;
            display: flex; flex-direction: column;
            border-right: 1px solid var(--chrome-border);
            box-shadow: 2px 0 6px rgba(0,0,0,0.10);
        }
        /* Scrollbar styling for sidebar */
        #toolbar::-webkit-scrollbar { width: 5px; }
        #toolbar::-webkit-scrollbar-track { background: var(--chrome-light); }
        #toolbar::-webkit-scrollbar-thumb { background: var(--chrome-border); border-radius: 3px; }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           BOTTOM BAR
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #bottomBar {
            position: fixed; bottom: 0; left: 0; right: 0; height: 44px;
            background: var(--chrome-dark);
            border-top: 2px solid #1a2535;
            display: flex; align-items: center; gap: 0;
            z-index: 1100; padding: 0 8px;
            overflow: hidden;
            box-shadow: 0 -2px 6px rgba(0,0,0,0.3);
        }
        .bb-labeled-group {
            display: flex; flex-direction: column; align-items: stretch;
            border-right: 1px solid #3d4f66; padding: 0 7px;
        }
        .bb-labeled-group:last-child { border-right: none; }
        .bb-group-label {
            font-size: 7.5px; text-transform: uppercase; letter-spacing: 0.9px;
            color: #5a7090; text-align: center; margin-bottom: 2px; white-space: nowrap;
            font-weight: 600;
        }
        .bb-labeled-group .bb-row {
            display: flex; align-items: center; gap: 3px;
        }
        .bb-btn {
            background: rgba(255,255,255,0.09); border: 1px solid rgba(255,255,255,0.18);
            color: #b0c4d8; border-radius: 3px; padding: 3px 8px; cursor: pointer;
            font-size: 10.5px; font-weight: 500; display: flex; align-items: center;
            gap: 3px; white-space: nowrap; line-height: 1.3;
            transition: all 0.1s;
        }
        .bb-btn:hover { background: rgba(255,255,255,0.17); color: #ddeeff; border-color: rgba(255,255,255,0.32); }
        .bb-btn.bb-active { background: var(--blue-active); color: #e0f0ff; border-color: #4a90d0; }

        /* Scale â€” gold-tinted, prominent */
        #scaleGroup {
            display: flex; flex-direction: column; align-items: stretch;
            padding: 2px 12px; background: rgba(180,140,20,0.18);
            border-left: 2px solid var(--scale-gold); border-right: 2px solid var(--scale-gold);
            min-width: 160px;
        }
        #scaleGroupLabel {
            font-size: 7.5px; text-transform: uppercase; letter-spacing: 1px;
            color: #c9a830; text-align: center; margin-bottom: 2px; font-weight: 700;
        }
        #scaleGroupRow { display: flex; align-items: center; gap: 5px; }
        #scaleGroupRow span { font-size: 10px; color: #9a8060; white-space: nowrap; }
        #bbScale {
            width: 64px; background: var(--scale-bg); color: #2a1a00;
            border: 1px solid var(--scale-border); border-radius: 2px;
            padding: 2px 5px; font-size: 12px; font-weight: 600;
            font-family: 'Courier New', monospace;
        }
        #bbUnitsBtn {
            background: rgba(180,140,20,0.22); border: 1px solid var(--scale-border);
            color: #d4aa30; border-radius: 3px; padding: 3px 8px; cursor: pointer;
            font-size: 10px; font-weight: 600; white-space: nowrap;
        }
        #bbUnitsBtn:hover { background: rgba(180,140,20,0.35); }

        #bbAutosave { font-size: 9px; color: #4a6078; white-space: nowrap; padding: 0 6px; margin-left: auto; }

        /* â”€â”€ SIDEBAR sections â”€â”€ */
        .tb-section {
            padding: 9px 9px 8px;
            border-bottom: 1px solid var(--chrome-border);
            background: var(--chrome-light);
        }
        .tb-label {
            font-size: 8.5px; text-transform: uppercase; letter-spacing: 1.2px;
            color: var(--blue-label); margin-bottom: 7px; font-weight: 700;
        }

        /* Tool grid */
        .tool-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 4px;
        }
        .tool-btn {
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; gap: 2px; padding: 7px 4px; cursor: pointer;
            background: var(--btn-bg); color: var(--text-dark); border: 1px solid var(--btn-border);
            border-radius: 4px; font-size: 10px; text-align: center;
            transition: all 0.12s; position: relative; line-height: 1.2;
            box-shadow: 0 1px 2px rgba(0,0,0,0.08);
        }
        .tool-btn .t-ico { font-size: 15px; line-height: 1; }
        .tool-btn .t-lbl { font-size: 9px; color: var(--text-muted); font-weight: 500; }
        .tool-btn:hover { background: var(--btn-hover); color: var(--text-dark); border-color: #8090a8; box-shadow: 0 2px 4px rgba(0,0,0,0.12); }
        .tool-btn.active-mode {
            background: var(--blue-light) !important; color: var(--blue-active) !important;
            border-color: var(--blue-active) !important; box-shadow: 0 0 0 2px rgba(26,95,160,0.2) !important;
        }
        .tool-btn.active-mode .t-lbl { color: var(--blue-active) !important; }
        .key-hint {
            position: absolute; top: 3px; right: 4px;
            font-size: 7.5px; background: #e0e4ea; color: #5a6880;
            border-radius: 2px; padding: 0 3px; line-height: 1.6;
            border: 1px solid #c0c8d4;
        }

        /* Regular full-width buttons in sidebar */
        button {
            display: block; margin: 2px 0; padding: 6px 8px; cursor: pointer;
            width: 100%; text-align: left; font-size: 11px;
            background: var(--btn-bg); color: var(--text-dark); border: 1px solid var(--btn-border);
            border-radius: 3px; transition: background 0.1s;
            box-shadow: 0 1px 2px rgba(0,0,0,0.06);
        }
        button:hover { background: var(--btn-hover); border-color: #8090a8; }
        .active-mode { background: var(--blue-light) !important; color: var(--blue-active) !important; border-color: var(--blue-active) !important; }
        .btn-danger { background: var(--danger-bg) !important; border-color: var(--danger-border) !important; color: var(--danger-text) !important; }
        .btn-danger:hover { background: #f5d0d0 !important; }
        .btn-sm { font-size: 10px; padding: 3px 6px; }

        /* Layer toggle pill */
        .layer-toggle {
            display: flex; gap: 0; border-radius: 4px; overflow: hidden;
            border: 1px solid var(--btn-border); margin-bottom: 4px;
        }
        .layer-btn {
            flex: 1; text-align: center; padding: 6px 4px; font-size: 10px;
            background: var(--btn-bg); color: var(--text-muted); border: none; border-radius: 0;
            cursor: pointer; transition: all 0.15s; margin: 0; font-weight: 500;
        }
        .layer-btn:first-child { border-right: 1px solid var(--btn-border); }
        .layer-btn:hover { background: var(--btn-hover); color: var(--text-dark); }
        .layer-btn.layer-active { background: var(--blue-light); color: var(--blue-active); font-weight: 700; }
        #layerHint { font-size: 9px; color: var(--text-muted); line-height: 1.4; padding: 2px 0; min-height: 24px; }

        /* Fill pattern swatches */
        .fp-swatch {
            width: 100%; aspect-ratio: 1; padding: 0 !important;
            border-radius: 3px !important; display: flex !important;
            align-items: center; justify-content: center;
            font-size: 12px; cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            min-height: 20px;
        }
        .fp-swatch:hover { transform: scale(1.12); box-shadow: 0 0 0 2px var(--blue-active); }
        .fp-swatch.fill-selected { box-shadow: 0 0 0 2px #d4aa30 !important; }

        /* Style row */
        .style-row { display: flex; gap: 4px; }
        .style-row button { flex: 1; text-align: center; font-size: 10px; }

        /* Scale input row */
        .scale-row { display: flex; align-items: center; gap: 4px; font-size: 10px; color: var(--text-muted); margin-top: 3px; }
        input[type="number"] {
            background: var(--btn-bg); color: var(--text-dark);
            border: 1px solid var(--btn-border); border-radius: 3px;
            padding: 3px 4px; font-size: 10px;
        }
        input[type="range"] { width: 100%; margin: 3px 0; accent-color: var(--blue-active); }
        input[type="file"] { font-size: 9px; color: var(--text-muted); width: 100%; margin-bottom: 2px; }

        /* Image upload drop zone */
        #imgDropZone {
            border: 2px dashed var(--chrome-border); border-radius: 5px;
            padding: 10px 6px; text-align: center; cursor: pointer;
            color: var(--text-muted); font-size: 10px; margin-bottom: 6px;
            transition: all 0.15s; background: var(--panel-bg);
        }
        #imgDropZone:hover, #imgDropZone.dragover { border-color: var(--blue-active); color: var(--blue-active); background: var(--blue-light); }
        #imgDropZone .drop-ico { font-size: 20px; display: block; margin-bottom: 3px; }
        #imgDropZone.has-image { border-style: solid; border-color: #2a8a3a; color: #1a6a2a; background: #e8f5ec; }
        #imageControls { display: none; }
        #imageControls.visible { display: block; }

        /* Tooltip â€” rendered via JS into a fixed div so it's never clipped by sidebar overflow */
        #floatTip {
            position: fixed; z-index: 9000; pointer-events: none;
            background: var(--chrome-dark); color: #d8e8f4;
            padding: 5px 9px; border-radius: 4px; font-size: 11px;
            white-space: nowrap; line-height: 1.4;
            border: 1px solid #3d5070; box-shadow: 0 3px 10px rgba(0,0,0,0.4);
            display: none;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CANVAS
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #canvas-container {
            position: fixed; top: 48px; left: 196px;
            width: calc(100vw - 196px); height: calc(100vh - 92px);
        }
        canvas { background: var(--canvas-bg); width: 100%; height: 100%; display: block; }

        /* Context hint bar */
        #contextHint {
            position: fixed; bottom: 80px; left: calc(196px + (100vw - 196px) / 2);
            transform: translateX(-50%);
            background: rgba(30,40,55,0.88); color: #d8eaf8;
            padding: 6px 16px; border-radius: 16px; font-size: 11px;
            pointer-events: none; white-space: nowrap; z-index: 900;
            border: 1px solid #3d5070; box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        #contextHint kbd {
            background: rgba(255,255,255,0.15); border-radius: 3px;
            padding: 1px 5px; font-size: 10px; font-family: monospace;
        }

        /* Status toast */
        #status {
            position: fixed; bottom: 56px; left: calc(196px + (100vw - 196px) / 2);
            transform: translateX(-50%);
            background: rgba(26,80,140,0.95); color: #e8f4ff;
            padding: 6px 18px; border-radius: 16px; font-size: 12px;
            font-weight: 600; display: none; z-index: 1100;
            pointer-events: none; white-space: nowrap;
            border: 1px solid #4a90d0;
        }

        /* Collapsible */
        .collapsible-label {
            display: flex; justify-content: space-between; align-items: center;
            cursor: pointer; user-select: none; padding: 0 0 6px 0;
        }
        .collapsible-label:hover { color: var(--text-dark); }
        .collapsible-arrow { font-size: 9px; color: var(--text-muted); transition: transform 0.2s; }
        .collapsible-arrow.open { transform: rotate(180deg); }
        .collapsible-body { overflow: hidden; transition: max-height 0.2s; }

        /* Debug overlay */
        #debug {
            position: fixed; top: 56px; right: 10px;
            background: rgba(0,0,0,0.85); color: #0f0;
            padding: 5px 8px; font-size: 10px; font-family: monospace;
            max-width: 240px; max-height: 160px; overflow-y: auto;
            border-radius: 4px; display: none; z-index: 1200;
        }
        .hidden { display: none !important; }

        /* Sidebar section hover highlight */
        .tb-section:hover { background: #eaeef3; }
    </style>
</head>
<body>

    <!-- â•â•â• TOP WORKFLOW BAR â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="topBar">
        <div id="appTitle"><svg width="22" height="20" viewBox="0 0 22 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:6px;flex-shrink:0;">
  <!-- Lot boundary polygon -->
  <polygon points="2,16 5,4 17,2 20,13 10,18" fill="none" stroke="#5a9fd4" stroke-width="1.4" stroke-linejoin="round"/>
  <!-- Corner survey stake at bottom-left -->
  <circle cx="2" cy="16" r="1.5" fill="#f0b840"/>
  <!-- Dimension tick on top edge -->
  <line x1="5" y1="4" x2="17" y2="2" stroke="#7ab8e8" stroke-width="0.7" stroke-dasharray="2 1.5"/>
  <!-- Interior area hatching (two faint diagonals) -->
  <line x1="7" y1="5" x2="12" y2="16" stroke="#5a9fd4" stroke-width="0.5" opacity="0.35"/>
  <line x1="11" y1="3.5" x2="18" y2="11" stroke="#5a9fd4" stroke-width="0.5" opacity="0.35"/>
</svg> Lot Designer</div>
        <div id="workflowSteps">
            <button class="wf-step wf-active" id="wfStep1" onclick="workflowStep(1)" data-tip="Upload a background survey or aerial image (optional)">
                <span class="wf-num">1</span>
                <span class="wf-ico"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle">
                  <rect x="1" y="1" width="14" height="14" rx="2" fill="#2a4a6a" stroke="#5588aa" stroke-width="0.8"/>
                  <rect x="2.5" y="2.5" width="4.5" height="4.5" fill="#3a6a9a" opacity="0.7"/>
                  <rect x="8.5" y="2.5" width="5" height="4.5" fill="#3a5a3a" opacity="0.7"/>
                  <rect x="2.5" y="8.5" width="5" height="5" fill="#5a4a2a" opacity="0.7"/>
                  <rect x="8.5" y="8.5" width="5" height="5" fill="#3a6a9a" opacity="0.5"/>
                  <line x1="7.5" y1="1" x2="7.5" y2="15" stroke="#88aacc" stroke-width="0.5"/>
                  <line x1="1" y1="7.5" x2="15" y2="7.5" stroke="#88aacc" stroke-width="0.5"/>
                </svg></span>
                <span class="wf-lbl">Upload Background Image <span style="color:#5a8a5a;font-size:9px;font-weight:normal;">(optional)</span></span>
            </button>
            <button class="wf-step" id="wfStep2" onclick="workflowStep(2)" data-tip="Draw lot boundary lines â€” sets the total lot area">
                <span class="wf-num">2</span>
                <span class="wf-ico"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle">
                  <rect x="1" y="1" width="14" height="14" rx="2" fill="#2a4a6a" stroke="#5588aa" stroke-width="0.8"/>
                  <rect x="2.5" y="2.5" width="4.5" height="4.5" fill="#3a6a9a" opacity="0.5"/>
                  <rect x="8.5" y="2.5" width="5" height="4.5" fill="#3a5a3a" opacity="0.5"/>
                  <rect x="2.5" y="8.5" width="5" height="5" fill="#5a4a2a" opacity="0.5"/>
                  <rect x="8.5" y="8.5" width="5" height="5" fill="#3a6a9a" opacity="0.35"/>
                  <line x1="7.5" y1="1" x2="7.5" y2="15" stroke="#88aacc" stroke-width="0.4" opacity="0.5"/>
                  <line x1="1" y1="7.5" x2="15" y2="7.5" stroke="#88aacc" stroke-width="0.4" opacity="0.5"/>
                  <polygon points="4,10 8,3 13,6 12,13 4,13" fill="rgba(255,220,80,0.18)" stroke="#ffdd44" stroke-width="1.5" stroke-linejoin="round"/>
                  <circle cx="4" cy="10" r="1.2" fill="#ffdd44"/>
                  <circle cx="8" cy="3" r="1.2" fill="#ffdd44"/>
                  <circle cx="13" cy="6" r="1.2" fill="#ffdd44"/>
                  <circle cx="12" cy="13" r="1.2" fill="#ffdd44"/>
                  <circle cx="4" cy="13" r="1.2" fill="#ffdd44"/>
                </svg></span>
                <span class="wf-lbl">Draw Boundary</span>
            </button>
            <button class="wf-step" id="wfStep3" onclick="workflowStep(3)" data-tip="Add buildings, features, labels and dimensions">
                <span class="wf-num">3</span>
                <span class="wf-ico"><svg width="20" height="16" viewBox="0 0 20 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle">
                  <!-- House -->
                  <rect x="3" y="7" width="8" height="7" fill="#8B6914" stroke="#c49a2a" stroke-width="0.8"/>
                  <polygon points="1,8 7,2 13,8" fill="#a03030" stroke="#cc4444" stroke-width="0.8"/>
                  <rect x="5.5" y="10" width="3" height="4" fill="#5a3a1a"/>
                  <!-- Ruler -->
                  <rect x="13.5" y="2" width="5.5" height="11" rx="0.8" fill="#d4b96a" stroke="#b89840" stroke-width="0.7"/>
                  <line x1="14.5" y1="4" x2="16.2" y2="4" stroke="#7a6030" stroke-width="0.7"/>
                  <line x1="14.5" y1="6" x2="15.5" y2="6" stroke="#7a6030" stroke-width="0.7"/>
                  <line x1="14.5" y1="8" x2="16.2" y2="8" stroke="#7a6030" stroke-width="0.7"/>
                  <line x1="14.5" y1="10" x2="15.5" y2="10" stroke="#7a6030" stroke-width="0.7"/>
                  <line x1="14.5" y1="12" x2="16.2" y2="12" stroke="#7a6030" stroke-width="0.7"/>
                </svg></span>
                <span class="wf-lbl">Add Features &amp; Labels</span>
            </button>
        </div>
        <div id="topRight">
            <div class="top-sep"></div>
            <button class="top-action-btn" id="bbOpenBtn2" data-tip="Open a saved .lot file (Ctrl+O)">ğŸ“‚ Open</button>
            <!-- Save/Export dropdown -->
            <div style="position:relative;display:inline-block;" id="saveExportWrapper">
                <button class="top-action-btn" id="bbSaveExportBtn" data-tip="Save or export drawing" onclick="toggleSaveMenu()">
                    ğŸ’¾ Save / Export <span style="font-size:9px;opacity:0.7;">â–¾</span>
                </button>
                <div id="saveExportMenu" style="display:none;position:absolute;right:0;top:calc(100% + 3px);background:#fff;border:1px solid #b8c0ca;border-radius:5px;box-shadow:0 4px 16px rgba(0,0,0,0.22);z-index:2000;min-width:210px;overflow:hidden;">
                    <div style="padding:8px 12px 5px;font-size:9px;color:#6a7888;text-transform:uppercase;letter-spacing:0.8px;font-weight:600;border-bottom:1px solid #e4e8ed;">Save / Export</div>
                    <button onclick="saveDrawing();closeSaveMenu();" style="display:flex;align-items:flex-start;gap:10px;padding:10px 14px;background:none;border:none;border-radius:0;width:100%;text-align:left;cursor:pointer;border-bottom:1px solid #f0f2f4;" onmouseover="this.style.background='#f0f4fa'" onmouseout="this.style.background='none'">
                        <span style="font-size:18px;line-height:1;">ğŸ’¾</span>
                        <span>
                            <div style="font-size:12px;font-weight:600;color:#1a2535;">Save as .lot</div>
                            <div style="font-size:10px;color:#6a7888;">Can be re-opened and edited later</div>
                        </span>
                    </button>
                    <button onclick="exportPNG();closeSaveMenu();" style="display:flex;align-items:flex-start;gap:10px;padding:10px 14px;background:none;border:none;border-radius:0;width:100%;text-align:left;cursor:pointer;" onmouseover="this.style.background='#f0f4fa'" onmouseout="this.style.background='none'">
                        <span style="font-size:18px;line-height:1;">ğŸ–¼</span>
                        <span>
                            <div style="font-size:12px;font-weight:600;color:#1a2535;">Export as PNG</div>
                            <div style="font-size:10px;color:#6a7888;">Flat image â€” cannot be edited</div>
                        </span>
                    </button>
                </div>
            </div>
            <div class="top-sep"></div>
            <a href="https://docs.google.com/forms/d/e/1FAIpQLSfC_7gwd0SIO63pyiqEaSJ0z2ST9TxM5EA3ypPgv6prrwpGfQ/viewform?usp=publish-editor" target="_blank" rel="noopener"
               style="font-size:11px; color:#8aa8c4; white-space:nowrap; padding:0 8px; text-decoration:none; display:flex; align-items:center; gap:4px;"
               onmouseover="this.style.color='#e0ecf8'" onmouseout="this.style.color='#8aa8c4'">
               ğŸ’¬ Contact Us or Report an Issue
            </a>
            <div class="top-sep"></div>
            <div id="autosaveIndicator"></div>
        </div>
    </div>

    <!-- â•â•â• DISCLAIMER BAR â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="disclaimerBar">âš  This design tool makes no warranty for accuracy. Not a legal survey.</div>

    <!-- â•â•â• LEFT SIDEBAR â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="toolbar">

        <!-- â”€â”€ Tools â”€â”€ -->
        <div class="tb-section">
            <div class="tb-label">Tools</div>
            <div class="tool-grid">
                <button class="tool-btn" id="drawBtn" data-steps="2,3" data-tip="Click to place points â€” click first point to close shape">
                    <span class="key-hint">D</span>
                    <span class="t-ico">âœ</span><span class="t-lbl">Draw</span>
                </button>
                <button class="tool-btn" id="selectBtn" data-steps="1,2,3" data-tip="Select shapes or labels â€” drag to move, Del to delete">
                    <span class="key-hint">S</span>
                    <span class="t-ico">â†–</span><span class="t-lbl">Select</span>
                </button>
                <button class="tool-btn" id="panBtn" data-steps="1,2,3" data-tip="Drag to pan the view. Space+drag works in any mode">
                    <span class="key-hint">H</span>
                    <span class="t-ico">âœ‹</span><span class="t-lbl">Pan</span>
                </button>
                <button class="tool-btn" id="measureBtn" data-steps="3" data-tip="Click two points to add a dimension line with measurement">
                    <span class="key-hint">M</span>
                    <span class="t-ico">âŸ·</span><span class="t-lbl">Dimension</span>
                </button>
                <button class="tool-btn" id="textBtn" data-steps="3" data-tip="Click on the canvas to place a formatted text label">
                    <span class="key-hint">T</span>
                    <span class="t-ico">T</span><span class="t-lbl">Add Text Label</span>
                </button>
                <button class="tool-btn" id="editTextBtn" data-steps="2,3" data-tip="Click any label or text on the canvas to edit it">
                    <span class="t-ico">âœ</span><span class="t-lbl">Edit Labels</span>
                </button>
                <button class="tool-btn" id="paintBtn" data-steps="3" data-tip="Click a polygon to apply or change its fill pattern">
                    <span class="key-hint">P</span>
                    <span class="t-ico">ğŸª£</span><span class="t-lbl">Fill Shape</span>
                </button>
                <button class="tool-btn" id="moveImageBtn" data-steps="1" data-tip="Drag the background image to reposition or rescale it">
                    <span class="t-ico"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 1L6 4h4L8 1z" fill="currentColor"/><path d="M8 15l-2-3h4L8 15z" fill="currentColor"/><path d="M1 8l3-2v4L1 8z" fill="currentColor"/><path d="M15 8l-3-2v4l3-2z" fill="currentColor"/><line x1="8" y1="2" x2="8" y2="14" stroke="currentColor" stroke-width="1.3"/><line x1="2" y1="8" x2="14" y2="8" stroke="currentColor" stroke-width="1.3"/></svg></span>
                    <span class="t-lbl">Move Image</span>
                </button>
            </div>
        </div>

        <!-- â”€â”€ Drawing Layer (hidden â€” kept for JS compat) â”€â”€ -->
        <div id="layerSection" style="display:none;">
            <div class="layer-toggle">
                <button class="layer-btn layer-active" id="boundaryLayerBtn">ğŸ  Boundary</button>
                <button class="layer-btn" id="featureLayerBtn">ğŸŒ³ Feature</button>
            </div>
            <button id="layerBtn" style="display:none">Boundary</button>
            <div id="layerHint"></div>
        </div>

        <!-- â”€â”€ Style â”€â”€ -->
        <div class="tb-section" id="styleSection" data-steps="2,3">
            <div class="tb-label">Style</div>
            <div class="style-row">
                <button id="lineStyleBtn" data-tip="Cycle line thickness: Thin â†’ Medium â†’ Thick â†’ Dashed">â”€ Thin</button>
                <button id="colorBtn" data-tip="Cycle colour for new shapes and selected items">â— Black</button>
            </div>
            <button id="fillBtn" data-tip="Choose a fill pattern for polygon interiors" style="margin-top:4px;">ğŸª£ Fill Pattern â–¾</button>
            <div id="fillPatterns" style="display:none; margin-top:6px;">
                <div style="font-size:9px;color:#666;margin-bottom:4px;text-transform:uppercase;letter-spacing:0.8px;">Solid</div>
                <div style="display:grid;grid-template-columns:repeat(7,1fr);gap:3px;margin-bottom:6px;">
                    <button class="fill-pattern btn-sm fp-swatch" data-fill="none" title="No fill" style="background:repeating-conic-gradient(#ddd 0% 25%,#eee 0% 50%) 0 0/8px 8px;border:1px solid #ccc;">âœ•</button>
                    <button class="fill-pattern btn-sm fp-swatch" data-fill="solid-lightgray" title="Light Gray" style="background:#c8c8c8;border:1px solid #aaa;"></button>
                    <button class="fill-pattern btn-sm fp-swatch" data-fill="solid-green"  title="Solid Green"  style="background:#2d7a2d;border:1px solid #3a9a3a;"></button>
                    <button class="fill-pattern btn-sm fp-swatch" data-fill="solid-blue"   title="Solid Blue"   style="background:#1a6abf;border:1px solid #2a80dd;"></button>
                    <button class="fill-pattern btn-sm fp-swatch" data-fill="solid-brown"  title="Solid Brown"  style="background:#7a4010;border:1px solid #9a5518;"></button>
                    <button class="fill-pattern btn-sm fp-swatch" data-fill="solid-red"    title="Solid Red"    style="background:#bb1515;border:1px solid #dd2222;"></button>
                    <button class="fill-pattern btn-sm fp-swatch" data-fill="solid-gray"   title="Mid Gray"     style="background:#888;border:1px solid #aaa;"></button>
                    <button class="fill-pattern btn-sm fp-swatch" data-fill="solid-black"  title="Solid Black"  style="background:#111;border:1px solid #555;"></button>
                </div>
                <div style="font-size:9px;color:#666;margin-bottom:4px;text-transform:uppercase;letter-spacing:0.8px;">Hatch</div>
                <div style="display:grid;grid-template-columns:repeat(6,1fr);gap:3px;margin-bottom:6px;">
                    <button class="fill-pattern btn-sm fp-swatch" data-fill="hatch-darkgray" title="Hatch Dark Slate" style="background:#2a3540;border:1px solid #445566;opacity:0.9;">â‹°</button>
                    <button class="fill-pattern btn-sm fp-swatch" data-fill="hatch-gray"   title="Hatch Gray"   style="background:#888;border:1px solid #aaa;opacity:0.7;">â‹°</button>
                    <button class="fill-pattern btn-sm fp-swatch" data-fill="hatch-green"  title="Hatch Green"  style="background:#2d7a2d;border:1px solid #3a9a3a;opacity:0.7;">â‹°</button>
                    <button class="fill-pattern btn-sm fp-swatch" data-fill="hatch-blue"   title="Hatch Blue"   style="background:#1a6abf;border:1px solid #2a80dd;opacity:0.7;">â‹°</button>
                    <button class="fill-pattern btn-sm fp-swatch" data-fill="hatch-brown"  title="Hatch Brown"  style="background:#7a4010;border:1px solid #9a5518;opacity:0.7;">â‹°</button>
                    <button class="fill-pattern btn-sm fp-swatch" data-fill="hatch-black"  title="Hatch Black"  style="background:#222;border:1px solid #555;opacity:0.7;">â‹°</button>
                </div>
                <!-- Fill opacity slider -->
                <div style="border-top:1px solid #d0d4d8;padding-top:6px;margin-top:2px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:3px;">
                        <span style="font-size:9px;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.8px;font-weight:600;">Fill Opacity</span>
                        <span id="fillOpacityLabel" style="font-size:9px;font-weight:600;color:var(--blue-label);">50%</span>
                    </div>
                    <input type="range" id="fillOpacitySlider" min="5" max="100" value="50"
                        style="width:100%;accent-color:var(--blue-active);" data-tip="Opacity of polygon fill">
                </div>
            </div>
        </div>

        <!-- â”€â”€ Scale display in draw boundary step â”€â”€ -->
        <div class="tb-section" id="scaleDisplaySection" data-steps="2" style="background:rgba(200,168,0,0.08);border-left:3px solid var(--scale-gold);">
            <div class="tb-label" style="color:var(--scale-gold);">ğŸ“ Scale</div>
            <div style="display:flex;align-items:center;gap:5px;margin-bottom:4px;">
                <span style="font-size:10px;color:var(--text-muted);">1 px =</span>
                <input type="number" id="sidebarScale" value="0.35" min="0.001" step="0.001"
                    style="width:72px;background:var(--scale-bg);color:#2a1a00;border:1px solid var(--scale-border);border-radius:3px;padding:3px 5px;font-size:12px;font-weight:600;font-family:'Courier New',monospace;"
                    data-tip="Drawing scale â€” how many real-world units per pixel">
                <span id="sidebarUnitLabel" style="font-size:11px;color:var(--scale-gold);font-weight:700;">ft</span>
            </div>
            <button id="sidebarUnitsBtn" style="font-size:10px;padding:4px 6px;background:rgba(200,168,0,0.12);border-color:var(--scale-border);color:var(--scale-gold);font-weight:600;" data-tip="Toggle Imperial/Metric units">Units: Imperial</button>
            <div style="margin-top:9px;padding:7px 8px;background:#fff8e8;border:1px solid #e8c840;border-radius:4px;font-size:9px;color:#6a4a00;line-height:1.55;">
                <strong style="color:#7a3a00;">âš  IMPORTANT:</strong> Scale does not automatically match your background image.<br><br>
                Adjust scale precisely (e.g. <code style="background:#fef0c0;padding:1px 3px;border-radius:2px;font-family:'Courier New',monospace;">0.350</code>) so that a displayed dimension matches a known real-world measurement â€” such as your known lot frontage.
            </div>
        </div>
        <!-- â”€â”€ Step 2 nav â”€â”€ -->
        <div class="tb-section" data-steps="2" style="padding:7px 9px;">
            <div style="display:flex;gap:6px;">
                <button onclick="workflowStep(1)" style="flex:1;text-align:center;font-size:10px;padding:5px 0;background:var(--panel-bg);border-color:var(--chrome-border);color:var(--text-muted);">â† Back</button>
                <button onclick="workflowStep(3)" style="flex:2;text-align:center;font-size:11px;padding:6px 0;background:var(--blue-active);border-color:#4a90d0;color:#fff;font-weight:600;">Next â†’</button>
            </div>
        </div>

        <!-- â”€â”€ Background Image (step 1 only) â”€â”€ -->
        <div class="tb-section" id="imageSection" data-steps="1">
            <div class="tb-label">Background Image <span style="color:var(--text-muted);font-weight:normal;text-transform:none;font-size:9px;">(optional)</span></div>
            <div style="font-size:9px;color:var(--text-mid);line-height:1.5;margin-bottom:8px;padding:6px 7px;background:var(--blue-light);border-radius:4px;border-left:2px solid var(--blue-active);">
                Aerial lot imagery may be available through local GIS services â€” try searching <em style="color:var(--blue-active);">"[Your City] GIS map"</em>. Screenshot and upload here as a drawing reference.
            </div>
            <div id="imgDropZone" onclick="document.getElementById('imageUpload').click()" data-tip="Upload a survey image or aerial photo as a drawing reference">
                <span class="drop-ico">ğŸ›°</span>
                Click to upload image<br><span style="font-size:9px;color:var(--text-muted);">or drag &amp; drop here</span>
            </div>
            <input type="file" id="imageUpload" accept="image/*" style="display:none">
            <div id="imageControls">
                <div id="imageRotationControl" class="hidden" style="margin-top:3px;">
                    <label style="font-size:9px;color:var(--text-muted);">Rotation: <input type="number" id="imageRotation" value="0" min="0" max="360" style="width:48px;"> Â°</label>
                </div>
            </div>
            <!-- Opacity slider visible in step 1 sidebar -->
            <div style="margin-top:8px;">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:3px;">
                    <span style="font-size:9px;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.8px;font-weight:600;">Opacity</span>
                    <span id="sidebarOpacityLabel" style="font-size:9px;color:var(--blue-label);font-weight:600;">50%</span>
                </div>
                <input type="range" id="sidebarTransparency" min="0" max="1" step="0.05" value="0.5"
                    style="width:100%;accent-color:var(--blue-active);" data-tip="Background image opacity">
            </div>
            <button id="skipToDrawBtn" style="margin-top:8px;background:var(--blue-active);border-color:#4a90d0;color:#e8f2ff;font-size:11px;text-align:center;padding:7px 0;font-weight:600;border-radius:4px;">
                Next
            </button>
        </div>

        <!-- â”€â”€ Step 3 nav â”€â”€ -->
        <div class="tb-section" data-steps="3" style="padding:7px 9px;">
            <button onclick="workflowStep(2)" style="width:100%;text-align:center;font-size:10px;padding:5px 0;background:var(--panel-bg);border-color:var(--chrome-border);color:var(--text-muted);">â† Back to Boundary</button>
        </div>

        <!-- â”€â”€ Hidden elements kept for JS compat â”€â”€ -->
        <div style="display:none;">
            <button id="toggleSnaps">90Â° Snaps: ON</button>
            <button id="perpSnapBtn">âŠ¥ Perp Snap: ON</button>
            <button id="saveBtn">ğŸ’¾ Save Drawing</button>
            <button id="openBtn">ğŸ“‚ Open Drawing</button>
            <button id="exportPngBtn">ğŸ–¼ Export PNG</button>
            <button id="exportBtn">â¬‡ Export SVG</button>
            <button id="clearBtn">ğŸ—‘ Clear All</button>
            <button id="undoBtn">â†© Undo</button>
            <button id="redoBtn">â†ª Redo</button>
            <button id="zoomToFitBtn">âŠ¡ Fit</button>
            <button id="unitsBtn">Units: Imperial</button>
            <input type="number" id="scale" value="0.35">
            <span id="unitLabel">ft</span>
            <input type="range" id="transparency" min="0" max="1" step="0.1" value="0.5">
            <button id="toggleImage">ğŸ‘ Toggle</button>
            <button id="moveImageBtn2" onclick="document.getElementById('moveImageBtn').click()">âœ‹ Move</button>
            <input type="file" id="openFileInput" accept=".lot,.json">
        </div>

    </div><!-- end #toolbar -->

    <!-- â•â•â• BOTTOM BAR â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="bottomBar">
        <!-- Hidden file inputs still needed -->
        <input type="file" id="bbOpenFileInput" accept=".lot,.json" style="display:none;">
        <!-- Edit/View -->
        <div class="bb-labeled-group">
            <div class="bb-group-label">Edit</div>
            <div class="bb-row">
                <button class="bb-btn" id="bbUndoBtn" data-tip="Undo (Ctrl+Z)">â†© Undo</button>
                <button class="bb-btn" id="bbRedoBtn" data-tip="Redo (Ctrl+Y)">â†ª Redo</button>
                <button class="bb-btn" id="bbFitBtn" data-tip="Zoom to fit all shapes">âŠ¡ Fit</button>
            </div>
        </div>
        <!-- Background image controls -->
        <div class="bb-labeled-group">
            <div class="bb-group-label">Background Image</div>
            <div class="bb-row">
                <button class="bb-btn" id="bbToggleImage" data-tip="Show/hide background image">ğŸ‘ Show</button>
                <span style="font-size:10px;color:#5a7090;">Opacity</span>
                <input type="range" id="bbTransparency" min="0" max="1" step="0.05" value="0.5" data-tip="Background image opacity" style="width:64px;accent-color:#4a90d0;">
                <button class="bb-btn" id="bbMoveImage" data-tip="Move/rescale background image"><svg width="12" height="12" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:3px"><path d="M8 1L6 4h4L8 1z" fill="currentColor"/><path d="M8 15l-2-3h4L8 15z" fill="currentColor"/><path d="M1 8l3-2v4L1 8z" fill="currentColor"/><path d="M15 8l-3-2v4l3-2z" fill="currentColor"/><line x1="8" y1="2" x2="8" y2="14" stroke="currentColor" stroke-width="1.3"/><line x1="2" y1="8" x2="14" y2="8" stroke="currentColor" stroke-width="1.3"/></svg>Move</button>
            </div>
        </div>
        <!-- SCALE â€” dominant gold section -->
        <div id="scaleGroup">
            <div id="scaleGroupLabel">ğŸ“ Drawing Scale</div>
            <div id="scaleGroupRow">
                <span>1 px&nbsp;=</span>
                <input type="number" id="bbScale" value="0.35" min="0.001" step="0.001"
                    data-tip="Drawing scale â€” real-world units per pixel">
                <button id="bbUnitsBtn" data-tip="Toggle Imperial/Metric units">Units: Imperial</button>
            </div>
        </div>
        <!-- Clear -->
        <div class="bb-labeled-group" style="border-right:none;">
            <div class="bb-group-label" style="color:#c06060;">Danger</div>
            <div class="bb-row">
                <button class="bb-btn" id="bbClearBtn"
                    style="background:rgba(180,40,40,0.22);border-color:rgba(200,80,80,0.5);color:#f0a0a0;"
                    data-tip="Clear all shapes â€” cannot be undone">ğŸ—‘ Clear All</button>
            </div>
        </div>
        <div id="bbAutosave"></div>
    </div>

    <div id="debug"></div>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>

    <!-- Text label overlay -->
    <div id="textOverlay" style="display:none; position:fixed; z-index:2000; pointer-events:all;">
        <div id="textOverlayBg" style="position:fixed;inset:0;background:rgba(20,35,55,0.55);"></div>
        <div id="textOverlayBox" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#ffffff;border:1px solid #b8c0ca;border-radius:8px;padding:16px 18px;min-width:340px;box-shadow:0 8px 40px rgba(0,0,0,0.3);font-family:'Inter',Arial,sans-serif;">
            <div id="textOverlayLabel" style="font-size:12px;color:#1e4a80;font-weight:600;margin-bottom:10px;text-transform:uppercase;letter-spacing:0.8px;">Add Text Label</div>
            <textarea id="textOverlayInput" rows="3" autocomplete="off" style="width:100%;background:#f8f9fb;color:#1a2535;border:1px solid #b8c0ca;border-radius:3px;padding:7px 9px;font-size:14px;font-family:Arial,sans-serif;outline:none;box-sizing:border-box;resize:vertical;min-height:60px;"></textarea>
            <div id="txtHint" style="font-size:10px;color:#6a7888;margin:3px 0 10px 0;"><kbd style="background:#e4e8ed;border:1px solid #b8c0ca;border-radius:2px;padding:1px 4px;">Shift+Enter</kbd> new line &nbsp;&middot;&nbsp; <kbd style="background:#e4e8ed;border:1px solid #b8c0ca;border-radius:2px;padding:1px 4px;">Enter</kbd> confirm &nbsp;&middot;&nbsp; <kbd style="background:#e4e8ed;border:1px solid #b8c0ca;border-radius:2px;padding:1px 4px;">Esc</kbd> cancel</div>
            <div id="txtFmtRow" style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:10px;align-items:center;">
                <select id="txtFont" style="background:#f8f9fb;color:#1a2535;border:1px solid #b8c0ca;border-radius:3px;padding:4px 6px;font-size:11px;">
                    <option value="Arial">Arial</option><option value="Courier New">Courier</option>
                    <option value="Georgia">Georgia</option><option value="Times New Roman">Times</option>
                    <option value="Verdana">Verdana</option><option value="Impact">Impact</option>
                </select>
                <select id="txtSize" style="background:#f8f9fb;color:#1a2535;border:1px solid #b8c0ca;border-radius:3px;padding:4px 6px;font-size:11px;">
                    <option value="8">8pt</option><option value="10">10pt</option><option value="12">12pt</option>
                    <option value="14" selected>14pt</option><option value="16">16pt</option>
                    <option value="20">20pt</option><option value="24">24pt</option><option value="32">32pt</option><option value="48">48pt</option>
                </select>
                <button id="txtBold" style="background:#eef3fa;color:#1a5fa0;border:1px solid #a8c0da;border-radius:3px;padding:4px 10px;font-size:13px;font-weight:bold;cursor:pointer;transition:all 0.12s;">B</button>
                <button id="txtItalic" style="background:#eef3fa;color:#1a5fa0;border:1px solid #a8c0da;border-radius:3px;padding:4px 10px;font-size:13px;font-style:italic;cursor:pointer;transition:all 0.12s;">I</button>
                <select id="txtAlign" style="background:#f8f9fb;color:#1a2535;border:1px solid #b8c0ca;border-radius:3px;padding:4px 6px;font-size:11px;">
                    <option value="left">Left</option><option value="center">Center</option><option value="right">Right</option>
                </select>
                <select id="txtColor" style="background:#f8f9fb;color:#1a2535;border:1px solid #b8c0ca;border-radius:3px;padding:4px 6px;font-size:11px;">
                    <option value="black">Black</option><option value="red">Red</option><option value="blue">Blue</option>
                    <option value="green">Green</option><option value="brown">Brown</option><option value="gray">Gray</option><option value="purple">Purple</option>
                </select>
            </div>
            <div id="txtPreview" style="background:#f8f9fb;border:1px solid #b8c0ca;border-radius:3px;padding:8px 10px;min-height:36px;margin-bottom:10px;color:#1a2535;white-space:pre-wrap;word-break:break-word;"></div>
            <div style="display:flex;gap:8px;justify-content:flex-end;">
                <button id="textOverlayCancel" style="padding:6px 14px;font-size:12px;background:#e4e8ed;color:#3d4f66;border:1px solid #b8c0ca;border-radius:3px;cursor:pointer;">Cancel</button>
                <button id="textOverlayOk" style="padding:6px 14px;font-size:12px;background:#1a5fa0;color:#fff;border:1px solid #4a90d0;border-radius:3px;cursor:pointer;font-weight:bold;">Place Text</button>
            </div>
        </div>
    </div>
    <!-- Context hint bar -->
    <div id="contextHint"></div>
    <!-- Status toast -->
    <div id="status"></div>
    <!-- Global fixed tooltip (escapes sidebar overflow) -->
    <div id="floatTip"></div>

    <script>
        // â”€â”€ Fixed-position tooltip (escapes sidebar overflow:auto clipping) â”€â”€â”€â”€â”€â”€
        (function() {
            const tip = document.getElementById('floatTip');
            let hideTimer = null;
            document.addEventListener('mouseover', e => {
                const el = e.target.closest('[data-tip]');
                if (!el) return;
                clearTimeout(hideTimer);
                tip.textContent = el.getAttribute('data-tip');
                tip.style.display = 'block';
                // Position to the right of the element, vertically centred
                const r = el.getBoundingClientRect();
                const tx = r.right + 8;
                const ty = r.top + r.height / 2;
                // Keep within viewport
                tip.style.left = Math.min(tx, window.innerWidth - tip.offsetWidth - 6) + 'px';
                tip.style.top  = Math.max(4, ty - tip.offsetHeight / 2) + 'px';
            });
            document.addEventListener('mouseout', e => {
                const el = e.target.closest('[data-tip]');
                if (!el) return;
                hideTimer = setTimeout(() => { tip.style.display = 'none'; }, 80);
            });
            document.addEventListener('mousemove', e => {
                if (tip.style.display === 'none') return;
                const el = e.target.closest('[data-tip]');
                if (!el) { tip.style.display = 'none'; return; }
                // Re-position tip so it follows if element scrolls
                const r = el.getBoundingClientRect();
                const tx = r.right + 8;
                const ty = r.top + r.height / 2;
                tip.style.left = Math.min(tx, window.innerWidth - tip.offsetWidth - 6) + 'px';
                tip.style.top  = Math.max(4, ty - tip.offsetHeight / 2) + 'px';
            });
        })();

        // Constants - ENHANCED: Zoom-dependent snapping
        const BASE_SNAP_DISTANCE = 15;    // screen-px radius for endpoint/vertex snapping
        const BASE_EDGE_SNAP_DISTANCE = 28; // screen-px radius for mid-edge snapping (larger target)
        const MIN_POLYGON_AREA = 500;
        const MIN_EDGE_INTERSECTION_DISTANCE = 5;
        
        // FIXED: Color mapping for proper CSS colors
        const COLOR_MAP = {
            'green': '#228B22',
            'blue': '#1E90FF', 
            'brown': '#8B4513',
            'red': '#DC143C',
            'gray': '#808080',
            'lightgray': '#c8c8c8',
            'darkgray': '#2a3540',
            'black': '#000000',
            'purple': '#6611dd'
        };
        
        // Helper: returns hex color with an alpha suffix for canvas strokeStyle/fillStyle
        function colorWithAlpha(colorName, alpha) {
            const hex = COLOR_MAP[colorName] || '#000000';
            // alpha is 0..1; convert to 2-digit hex
            const a = Math.round(Math.max(0, Math.min(1, alpha)) * 255).toString(16).padStart(2, '0');
            return hex + a;
        }

        // Professional survey/engineering drawing font
        // Real plats use single-stroke Gothic lettering; closest web-safe match is
        // Courier New (condensed, monospaced â€” matches the feel of hand-lettered survey drawings)
        const SURVEY_FONT_FAMILY = "'Courier New', 'Lucida Console', monospace";
        function surveyFont(sizePx) {
            return `${sizePx}px ${SURVEY_FONT_FAMILY}`;
        }
        function surveyFontBold(sizePx) {
            return `bold ${sizePx}px ${SURVEY_FONT_FAMILY}`;
        }

        // Draw text with a white halo so it pops off any background colour or image.
        // Caller must have already set ctx.font, ctx.textAlign, ctx.textBaseline.
        function haloText(text, x, y, fillColor) {
            ctx.save();
            ctx.lineWidth   = 2 / zoom;
            ctx.strokeStyle = 'rgba(255,255,255,0.7)';
            ctx.lineJoin    = 'round';
            ctx.strokeText(text, x, y);
            ctx.fillStyle   = fillColor;
            ctx.fillText(text, x, y);
            ctx.restore();
        }
        
        function getSnapDistance() {
            let snapDistance = BASE_SNAP_DISTANCE / zoom;
            if (zoom > 50) snapDistance = Math.max(0.2, snapDistance);
            else if (zoom > 20) snapDistance = Math.max(0.5, snapDistance);
            else if (zoom > 10) snapDistance = Math.max(1, snapDistance);
            return snapDistance;
        }

        function getEdgeSnapDistance() {
            // Edge snap uses a larger screen-space radius than endpoint snap,
            // making the yellow dot much easier to hit without zooming in.
            let snapDistance = BASE_EDGE_SNAP_DISTANCE / zoom;
            if (zoom > 50) snapDistance = Math.max(0.4, snapDistance);
            else if (zoom > 20) snapDistance = Math.max(1, snapDistance);
            else if (zoom > 10) snapDistance = Math.max(2, snapDistance);
            return snapDistance;
        }
        
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const container = document.getElementById('canvas-container');
        canvas.width = container.clientWidth - 2;
        canvas.height = container.clientHeight - 2;
        let ctx = canvas.getContext('2d');
        
        // State variables
        let mode = 'draw';
        let points = [];
        let shapes = [];
        let scale = 0.35;
        let zoom = 1;
        let offsetX = 0;
        let offsetY = 0;
        let selectedShape = null;
        let selectedShapes = new Set();   // multi-select set (Ctrl+click)
        let selectedPoint = null;
        let selectedEdge = null;
        let dragStart = null;
        let measurePoints = [];
        let previewPoint = null;
        let backgroundImage = null;
        let showImage = false;
        let imageOpacity = 0.5;
        let currentLineStyle = 'thin';
        let currentLineColor = 'black';
        let polygonFill = 'none';
        let polygonFillOpacity = 0.5; // 0â€“1, used for new shapes and fill slider
        let bisectionTarget = null;
        let currentSnapInfo = null;
        let selectedPolygonForFill = null;
        let enable90DegSnaps = true;
        let paintColor = 'solid-green';

        // â”€â”€ Layer system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // 'boundary' = lot boundary shapes: show total lot area, blue edge labels
        // 'feature'  = buildings, driveways, etc: show own dimensions in brown/teal,
        //              never subtracted from lot area
        let currentLayer = 'boundary';
        const LAYER_STYLES = {
            boundary: {
                areaColor:  '#e60000',   // strong red area label
                edgeColor:  '#0055ff',   // vivid blue edge labels
                areaSize:   16,
                edgeSize:   12,
                edgeBold:   true
            },
            feature: {
                areaColor:  '#009900',   // vivid green area label
                edgeColor:  '#009900',   // vivid green edge labels
                areaSize:   13,
                edgeSize:   9,
                edgeBold:   false
            }
        };

        // Unique shape ID generator - used as stable Map keys for per-edge label positions
        let _shapeIdCounter = 0;
        function newShapeId() { return ++_shapeIdCounter; }
        // Lazily assign a stable numeric ID to any shape object that lacks one
        function ensureShapeId(shape) {
            if (!shape.id) shape.id = newShapeId();
            return shape.id;
        }
        
        // ADDITION: Units toggle
        let useMetricUnits = false;
        
        // ADDITION: Text labels functionality  
        let textLabels = [];
        let pendingTextInput = null;
        
        // ADDITION: Helper functions for units
        function getDistanceUnit() {
            return useMetricUnits ? 'm' : 'ft';
        }
        
        function getAreaUnit() {
            return useMetricUnits ? 'mÂ²' : 'sq ft';
        }
        
        function convertDistance(distanceInFeet) {
            return useMetricUnits ? distanceInFeet * 0.3048 : distanceInFeet;
        }
        
        function convertArea(areaInSquareFeet) {
            return useMetricUnits ? areaInSquareFeet * 0.092903 : areaInSquareFeet;
        }
        
        function updateUnitLabels() {
            document.getElementById('unitLabel').textContent = getDistanceUnit();
            document.getElementById('unitsBtn').textContent = `Units: ${useMetricUnits ? 'Metric' : 'Imperial'}`;
            const bb = document.getElementById('bbUnitsBtn');
            if (bb) bb.textContent = `Units: ${useMetricUnits ? 'Metric' : 'Imperial'}`;
            if (typeof syncSidebarScaleUI === 'function') syncSidebarScaleUI();
        }
        
        // ENHANCED: New variables for enhanced features
        let enablePerpSnap = true;
        let measurePreviewInfo = null; // Store perpendicular snap info for measure preview
        
        // ADDITION: Label moving functionality
        let labelPositions = new Map(); // Custom label positions for polygons
        let selectedLabel = null;
        let labelMoveMode = false;
        
        // ADDITION: Text label moving functionality
        let selectedText = null;
        let textMoveMode = false;
        
        // ADDITION: Distance label moving functionality
        let distancePositions = new Map();
        let labelColors = new Map(); // per-label colour overrides // Custom positions for distance labels
        let selectedDistance = null;
        let distanceMoveMode = false;
        
        // ADDITION: Measurement line selection functionality
        let selectedMeasurement = null;
        
        // Image manipulation
        let imageTransform = { x: 0, y: 0, scale: 1, rotation: 0 };
        let imageMode = false;
        let imageDragActive = false;
        let imageDragStart = null;   // {mouseX, mouseY, imgX, imgY} at drag start
        
        // Performance optimization
        const shapeCache = new Map();
        let redrawTimeout;

        // History for undo/redo
        let history = [];
        let historyIndex = -1;
        let _historyRestoring = false; // guard: prevents saveHistoryState during restoreState

        const debugDiv = document.getElementById('debug');
        function debug(msg) {
            console.log(msg);
            debugDiv.innerHTML = msg + '<br>' + debugDiv.innerHTML.split('<br>').slice(0, 8).join('<br>');
        }
        
        // Non-blocking status message (replaces all alert() calls)
        let statusTimeout;
        function showStatus(msg, duration = 3000) {
            const el = document.getElementById('status');
            el.textContent = msg;
            el.style.display = 'block';
            clearTimeout(statusTimeout);
            statusTimeout = setTimeout(() => { el.style.display = 'none'; }, duration);
        }

        // Utility functions
        function safeToCanvasCoords(x, y) {
            try {
                const result = { x: (x - offsetX) / zoom, y: (y - offsetY) / zoom };
                if (!isFinite(result.x) || !isFinite(result.y)) {
                    console.warn('Invalid canvas coordinates:', result);
                    return { x: 0, y: 0 };
                }
                return result;
            } catch (error) {
                console.error('Error in coordinate transformation:', error);
                return { x: 0, y: 0 };
            }
        }

        function validateViewport() {
            if (!isFinite(zoom) || zoom <= 0) {
                zoom = 1;
                console.warn('Reset invalid zoom');
            }
            if (!isFinite(offsetX) || !isFinite(offsetY)) {
                offsetX = 0;
                offsetY = 0;
                console.warn('Reset invalid offset');
            }
            zoom = Math.max(0.1, Math.min(zoom, 100)); // Increased to 100x for extreme precision work
        }

        function validateShape(shape) {
            if (!shape || !shape.points || !Array.isArray(shape.points)) {
                return false;
            }
            
            if (shape.points.length < 2) {
                return false;
            }
            
            return shape.points.every(point => 
                point && 
                typeof point.x === 'number' && 
                typeof point.y === 'number' &&
                isFinite(point.x) && 
                isFinite(point.y)
            );
        }

        function removeDuplicatePoints(points, tolerance = null) {
            if (tolerance === null) tolerance = getSnapDistance();
            const cleaned = [];
            points.forEach(point => {
                const isDuplicate = cleaned.some(existing => 
                    Math.hypot(existing.x - point.x, existing.y - point.y) < tolerance
                );
                if (!isDuplicate) {
                    cleaned.push({ ...point });
                }
            });
            return cleaned;
        }

        function safeCalculateArea(points) {
            try {
                if (!points || points.length < 3) return 0;
                
                let area = 0;
                for (let i = 0; i < points.length - 1; i++) {
                    const j = (i + 1) % (points.length - 1);
                    const p1 = points[i];
                    const p2 = points[j];
                    
                    if (!p1 || !p2 || typeof p1.x !== 'number' || typeof p1.y !== 'number' ||
                        typeof p2.x !== 'number' || typeof p2.y !== 'number') {
                        console.warn('Invalid point data in area calculation:', p1, p2);
                        continue;
                    }
                    
                    area += p1.x * p2.y - p2.x * p1.y;
                }
                
                area = Math.abs(area / 2);
                return isFinite(area) ? area * scale * scale : 0;
            } catch (error) {
                console.error('Error calculating area:', error);
                return 0;
            }
        }

        function calculateCentroid(points) {
            if (points.length < 3) return { x: 0, y: 0 };
            
            let cx = 0, cy = 0, area = 0;
            for (let i = 0; i < points.length - 1; i++) {
                const xi = points[i].x;
                const yi = points[i].y;
                const xj = points[i + 1].x;
                const yj = points[i + 1].y;
                const a = xi * yj - xj * yi;
                area += a;
                cx += (xi + xj) * a;
                cy += (yi + yj) * a;
            }
            
            if (Math.abs(area) < 1e-6) {
                let sumX = 0, sumY = 0;
                for (let i = 0; i < points.length - 1; i++) {
                    sumX += points[i].x;
                    sumY += points[i].y;
                }
                return { x: sumX / (points.length - 1), y: sumY / (points.length - 1) };
            }
            
            area *= 3;
            return { x: cx / area, y: cy / area };
        }

        function closestPointOnSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) return { x: x1, y: y1 };
            
            let param = dot / lenSq;
            param = Math.max(0, Math.min(1, param));

            return {
                x: x1 + param * C,
                y: y1 + param * D
            };
        }

        // ENHANCED: Perpendicular point calculation
        function perpendicularPointOnSegment(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) return null;
            
            const param = dot / lenSq;
            
            return {
                x: x1 + param * C,
                y: y1 + param * D,
                isOnSegment: param >= 0 && param <= 1,
                distance: Math.abs(A * D - B * C) / Math.sqrt(lenSq)
            };
        }

        function isPointInShape(point, shape) {
            if (shape.type !== 'polygon') return false;
            
            let inside = false;
            const points = shape.points;
            
            for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                if (((points[i].y > point.y) !== (points[j].y > point.y)) &&
                    (point.x < (points[j].x - points[i].x) * (point.y - points[i].y) / (points[j].y - points[i].y) + points[i].x)) {
                    inside = !inside;
                }
            }
            
            return inside;
        }

        // Returns true if (x,y) is on or near shape â€” works for both polygons and lines
        function isClickNearShape(x, y, shape) {
            if (shape.type === 'polygon') return isPointInShape({ x, y }, shape);
            if (shape.type === 'line') {
                const tol = 12 / zoom;  // generous tolerance for line selection
                for (let i = 0; i < shape.points.length - 1; i++) {
                    const p1 = shape.points[i], p2 = shape.points[i + 1];
                    const proj = closestPointOnSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (Math.hypot(x - proj.x, y - proj.y) <= tol) return true;
                }
            }
            return false;
        }

        // ENHANCED: Zoom to fit all shapes
        function zoomToFit() {
            if (shapes.length === 0) return;
            
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            shapes.forEach(shape => {
                shape.points.forEach(point => {
                    minX = Math.min(minX, point.x);
                    maxX = Math.max(maxX, point.x);
                    minY = Math.min(minY, point.y);
                    maxY = Math.max(maxY, point.y);
                });
            });
            
            const padding = 50;
            const shapeWidth = maxX - minX;
            const shapeHeight = maxY - minY;
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            const scaleX = (canvasWidth - 2 * padding) / shapeWidth;
            const scaleY = (canvasHeight - 2 * padding) / shapeHeight;
            zoom = Math.min(scaleX, scaleY, 10); // Max 10x for fit-to-view (reasonable for overview)
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            offsetX = canvasWidth / 2 - centerX * zoom;
            offsetY = canvasHeight / 2 - centerY * zoom;
            
            debug(`Zoomed to fit: zoom=${zoom.toFixed(2)}`);
            requestRedraw();
        }

        // ENHANCED: Zoom to point functionality with more zoom levels
        function zoomToPoint(worldX, worldY, zoomLevel = 2) {
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            zoom = Math.min(zoomLevel, 100); // Allow up to 100x zoom
            offsetX = canvasWidth / 2 - worldX * zoom;
            offsetY = canvasHeight / 2 - worldY * zoom;
            
            debug(`Zoomed to point (${Math.round(worldX)}, ${Math.round(worldY)}) at ${zoom}x`);
            requestRedraw();
        }

        function getAllSnapPoints() {
            const allPoints = [];
            
            shapes.forEach(shape => {
                shape.points.forEach(point => {
                    allPoints.push(point);
                });
            });
            
            points.forEach(point => {
                allPoints.push(point);
            });
            
            return allPoints;
        }

        function getAllEdges() {
            const edges = [];
            const snapDistance = getSnapDistance();
            
            shapes.forEach(shape => {
                if (shape.type === 'line' || shape.type === 'polygon') {
                    for (let i = 0; i < shape.points.length - 1; i++) {
                        edges.push({
                            start: shape.points[i],
                            end: shape.points[i + 1],
                            shape: shape,
                            index: i
                        });
                    }
                }
            });
            
            for (let i = 0; i < points.length - 1; i++) {
                edges.push({
                    start: points[i],
                    end: points[i + 1],
                    shape: null,
                    index: i
                });
            }
            
            return edges;
        }

        // ENHANCED: Perpendicular snap for measure tool
        function findPerpendicularSnap(x, y, firstPoint) {
            if (!firstPoint || !enablePerpSnap) return null;
            
            const allEdges = getAllEdges();
            const snapDistance = getSnapDistance();
            let bestPerpSnap = null;
            let minDistance = snapDistance * 2; // Larger search radius for perp snaps
            
            allEdges.forEach(edge => {
                const perpResult = perpendicularPointOnSegment(
                    firstPoint.x, firstPoint.y,
                    edge.start.x, edge.start.y,
                    edge.end.x, edge.end.y
                );
                
                if (perpResult) {
                    // Check if the current mouse position is reasonably close to this perpendicular
                    const distToMouse = Math.hypot(x - perpResult.x, y - perpResult.y);
                    
                    if (distToMouse < minDistance) {
                        minDistance = distToMouse;
                        bestPerpSnap = {
                            x: perpResult.x,
                            y: perpResult.y,
                            type: 'perpendicular',
                            edge: edge,
                            distance: perpResult.distance,
                            isOnSegment: perpResult.isOnSegment,
                            firstPoint: firstPoint
                        };
                    }
                }
            });
            
            return bestPerpSnap;
        }

        function findBestSnapPoint(x, y) {
            const allPoints = getAllSnapPoints();
            const allEdges = getAllEdges();
            const snapDistance = getSnapDistance();
            
            let alignmentGuides = [];
            
            if (enable90DegSnaps) {
                allPoints.forEach(point => {
                    if (Math.abs(y - point.y) < 10 / zoom) {
                        alignmentGuides.push({ type: 'horizontal', y: point.y, alignPoint: point });
                    }
                    if (Math.abs(x - point.x) < 10 / zoom) {
                        alignmentGuides.push({ type: 'vertical', x: point.x, alignPoint: point });
                    }
                });
            }
            
            // ENHANCED: Special handling for measure mode perpendicular snap
            if (mode === 'measure' && measurePoints.length === 1 && enablePerpSnap) {
                const perpSnap = findPerpendicularSnap(x, y, measurePoints[0]);
                if (perpSnap) {
                    currentSnapInfo = {
                        x: perpSnap.x,
                        y: perpSnap.y,
                        type: 'perpendicular',
                        edge: perpSnap.edge,
                        distance: perpSnap.distance,
                        isOnSegment: perpSnap.isOnSegment,
                        firstPoint: perpSnap.firstPoint,
                        alignmentGuides: alignmentGuides
                    };
                    debug(`Perpendicular snap: distance=${perpSnap.distance.toFixed(1)} ${perpSnap.isOnSegment ? 'on' : 'extended'} segment`);
                    return currentSnapInfo;
                }
            }
            
            // Original snap logic with zoom-dependent distances
            if (points.length >= 3) {
                const firstPoint = points[0];
                const dist = Math.hypot(x - firstPoint.x, y - firstPoint.y);
                if (dist < snapDistance) {
                    currentSnapInfo = {
                        x: firstPoint.x,
                        y: firstPoint.y,
                        type: 'firstPoint',
                        isFirstPoint: true,
                        alignmentGuides: alignmentGuides
                    };
                    debug('Snap: firstPoint (polygon completion)');
                    return currentSnapInfo;
                }
            }
            
            if (points.length === 3 && mode === 'draw') {
                const [p1, p2, p3] = points;
                const v1 = { x: p2.x - p1.x, y: p2.y - p1.y };
                const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
                const p4 = { x: p1.x + v2.x, y: p1.y + v2.y };
                
                const dist = Math.hypot(x - p4.x, y - p4.y);
                if (dist < snapDistance * 1.5) {
                    currentSnapInfo = {
                        x: p4.x,
                        y: p4.y,
                        type: 'rectangleCorner',
                        alignmentGuides: alignmentGuides
                    };
                    debug('Snap: rectangleCorner');
                    return currentSnapInfo;
                }
            }

            let directionalConstraint = null;
            let constrainedPoint = { x, y };
            
            if (enable90DegSnaps && (mode === 'draw' || mode === 'measure')) {
                // In draw mode use points[], in measure mode use measurePoints[]
                const refArray = (mode === 'measure') ? measurePoints : points;
                if (refArray.length > 0) {
                const lastPoint = refArray[refArray.length - 1];
                
                const horizontalDist = Math.abs(y - lastPoint.y);
                const verticalDist = Math.abs(x - lastPoint.x);
                
                if (horizontalDist < snapDistance) {
                    directionalConstraint = {
                        type: 'horizontal',
                        constrainedY: lastPoint.y,
                        referencePoint: lastPoint,
                        source: 'lastPoint'
                    };
                    constrainedPoint.y = lastPoint.y;
                } else if (verticalDist < snapDistance) {
                    directionalConstraint = {
                        type: 'vertical',
                        constrainedX: lastPoint.x,
                        referencePoint: lastPoint,
                        source: 'lastPoint'
                    };
                    constrainedPoint.x = lastPoint.x;
                }
                } // end refArray.length > 0
            }
            
            if (!directionalConstraint && enable90DegSnaps) {
                alignmentGuides.forEach(guide => {
                    if (guide.type === 'horizontal' && Math.abs(y - guide.y) < snapDistance) {
                        directionalConstraint = {
                            type: 'horizontal',
                            constrainedY: guide.y,
                            referencePoint: guide.alignPoint,
                            source: 'alignment'
                        };
                        constrainedPoint.y = guide.y;
                    } else if (guide.type === 'vertical' && Math.abs(x - guide.x) < snapDistance) {
                        directionalConstraint = {
                            type: 'vertical',
                            constrainedX: guide.x,
                            referencePoint: guide.alignPoint,
                            source: 'alignment'
                        };
                        constrainedPoint.x = guide.x;
                    }
                });
            }

            let closestEndpoint = null;
            let minEndpointDist = snapDistance;
            
            allPoints.forEach(point => {
                const testX = directionalConstraint && directionalConstraint.type === 'vertical' ? constrainedPoint.x : point.x;
                const testY = directionalConstraint && directionalConstraint.type === 'horizontal' ? constrainedPoint.y : point.y;
                const dist = Math.hypot(constrainedPoint.x - testX, constrainedPoint.y - testY);
                
                if (dist < minEndpointDist) {
                    minEndpointDist = dist;
                    closestEndpoint = {
                        x: testX,
                        y: testY,
                        type: 'endpoint',
                        originalPoint: point
                    };
                }
            });
            
            if (closestEndpoint) {
                currentSnapInfo = {
                    x: closestEndpoint.x,
                    y: closestEndpoint.y,
                    type: directionalConstraint ? 'constrainedEndpoint' : 'endpoint',
                    originalPoint: closestEndpoint.originalPoint,
                    constraint: directionalConstraint,
                    alignmentGuides: alignmentGuides
                };
                debug(`Snap: ${directionalConstraint ? 'constrainedEndpoint' : 'endpoint'}`);
                return currentSnapInfo;
            }

            let bestEdgeSnap = null;
            let minEdgeDist = getEdgeSnapDistance();  // larger radius than endpoint snap
            
            allEdges.forEach(edge => {
                const projected = closestPointOnSegment(constrainedPoint.x, constrainedPoint.y, edge.start.x, edge.start.y, edge.end.x, edge.end.y);
                const dist = Math.hypot(constrainedPoint.x - projected.x, constrainedPoint.y - projected.y);
                
                if (dist < minEdgeDist) {
                    minEdgeDist = dist;
                    bestEdgeSnap = {
                        x: projected.x,
                        y: projected.y,
                        type: 'edge',
                        shape: edge.shape,
                        edgeStart: edge.start,
                        edgeEnd: edge.end
                    };
                }
            });
            
            if (bestEdgeSnap) {
                let finalX = bestEdgeSnap.x;
                let finalY = bestEdgeSnap.y;
                
                // Only use constrainedEdge (orange) if the constraint is doing real work:
                // if the cursor is already close to the edge on its own, prefer plain yellow edge snap.
                let useConstraint = false;
                if (directionalConstraint) {
                    const rawDistToEdge = Math.hypot(x - bestEdgeSnap.x, y - bestEdgeSnap.y);
                    const edgeTol = getEdgeSnapDistance();
                    if (rawDistToEdge > edgeTol * 0.55) {
                        useConstraint = true;
                        if (directionalConstraint.type === 'horizontal') {
                            finalY = directionalConstraint.constrainedY;
                        } else if (directionalConstraint.type === 'vertical') {
                            finalX = directionalConstraint.constrainedX;
                        }
                    }
                }
                
                currentSnapInfo = {
                    x: finalX,
                    y: finalY,
                    type: useConstraint ? 'constrainedEdge' : 'edge',
                    shape: bestEdgeSnap.shape,
                    edgeStart: bestEdgeSnap.edgeStart,
                    edgeEnd: bestEdgeSnap.edgeEnd,
                    constraint: useConstraint ? directionalConstraint : null,
                    alignmentGuides: alignmentGuides
                };
                debug(`Snap: ${useConstraint ? 'constrainedEdge' : 'edge'}`);
                return currentSnapInfo;
            }
            
            if (directionalConstraint) {
                currentSnapInfo = {
                    x: constrainedPoint.x,
                    y: constrainedPoint.y,
                    type: directionalConstraint.source === 'alignment' ? 'alignmentConstraint' : directionalConstraint.type,
                    referencePoint: directionalConstraint.referencePoint,
                    constraint: directionalConstraint,
                    alignmentGuides: alignmentGuides
                };
                debug(`Constraint: ${directionalConstraint.type} ${directionalConstraint.source}`);
                return currentSnapInfo;
            }
            
            currentSnapInfo = {
                type: 'none',
                x: x,
                y: y,
                alignmentGuides: enable90DegSnaps ? alignmentGuides : []
            };
            
            return null;
        }

        function checkForBisection() {
            if (points.length < 2) return null;
            
            for (const shape of shapes) {
                if (shape.type === 'polygon' && validateShape(shape)) {
                    const intersections = findLinePolygonIntersections(points, shape);
                    if (intersections.length >= 2) {
                        debug(`Found bisection target with ${intersections.length} intersections`);
                        return { polygon: shape, intersections };
                    }
                    
                    const endpointConnections = findEndpointEdgeConnections(points, shape);
                    if (endpointConnections.length >= 2) {
                        debug(`Found bisection target via endpoint-edge connections`);
                        return { polygon: shape, intersections: endpointConnections };
                    }
                }
            }
            
            return null;
        }

        function findLinePolygonIntersections(line, polygon) {
            const intersections = [];
            const polyPoints = polygon.points.slice(0, -1);
            
            for (let i = 0; i < line.length - 1; i++) {
                const lineStart = line[i];
                const lineEnd = line[i + 1];
                
                for (let j = 0; j < polyPoints.length; j++) {
                    const polyStart = polyPoints[j];
                    const polyEnd = polyPoints[(j + 1) % polyPoints.length];
                    
                    const intersection = getLineIntersection(lineStart, lineEnd, polyStart, polyEnd);
                    
                    if (intersection) {
                        const distToPolyStart = Math.hypot(intersection.x - polyStart.x, intersection.y - polyStart.y);
                        const distToPolyEnd = Math.hypot(intersection.x - polyEnd.x, intersection.y - polyEnd.y);
                        
                        if (distToPolyStart > 3 && distToPolyEnd > 3) {
                            const isDuplicate = intersections.some(existing => 
                                Math.hypot(existing.point.x - intersection.x, existing.point.y - intersection.y) < 3
                            );
                            
                            if (!isDuplicate) {
                                intersections.push({
                                    point: intersection,
                                    polygonEdgeIndex: j,
                                    lineSegmentIndex: i,
                                    type: 'crossing'
                                });
                                debug(`Line crosses polygon edge ${j} at (${Math.round(intersection.x)}, ${Math.round(intersection.y)})`);
                            }
                        }
                    }
                }
            }
            
            return intersections;
        }

        function findEndpointEdgeConnections(line, polygon) {
            const connections = [];
            const polyPoints = polygon.points.slice(0, -1);
            const lineStart = line[0];
            const lineEnd = line[line.length - 1];
            const snapDistance = getSnapDistance();
            
            for (let j = 0; j < polyPoints.length; j++) {
                const polyStart = polyPoints[j];
                const polyEnd = polyPoints[(j + 1) % polyPoints.length];
                
                const projected = closestPointOnSegment(lineStart.x, lineStart.y, polyStart.x, polyStart.y, polyEnd.x, polyEnd.y);
                const distToEdge = Math.hypot(lineStart.x - projected.x, lineStart.y - projected.y);
                
                if (distToEdge < snapDistance) {
                    const distToPolyStart = Math.hypot(projected.x - polyStart.x, projected.y - polyStart.y);
                    const distToPolyEnd = Math.hypot(projected.x - polyEnd.x, projected.y - polyEnd.y);
                    
                    if (distToPolyStart > 3 && distToPolyEnd > 3) {
                        connections.push({
                            point: { x: lineStart.x, y: lineStart.y },
                            polygonEdgeIndex: j,
                            lineSegmentIndex: 0,
                            type: 'endpoint-to-edge'
                        });
                        debug(`Line start connects to polygon edge ${j}`);
                    }
                }
            }
            
            for (let j = 0; j < polyPoints.length; j++) {
                const polyStart = polyPoints[j];
                const polyEnd = polyPoints[(j + 1) % polyPoints.length];
                
                const projected = closestPointOnSegment(lineEnd.x, lineEnd.y, polyStart.x, polyStart.y, polyEnd.x, polyEnd.y);
                const distToEdge = Math.hypot(lineEnd.x - projected.x, lineEnd.y - projected.y);
                
                if (distToEdge < snapDistance) {
                    const distToPolyStart = Math.hypot(projected.x - polyStart.x, projected.y - polyStart.y);
                    const distToPolyEnd = Math.hypot(projected.x - polyEnd.x, projected.y - polyEnd.y);
                    
                    if (distToPolyStart > 3 && distToPolyEnd > 3) {
                        const isDuplicate = connections.some(existing => 
                            Math.hypot(existing.point.x - lineEnd.x, existing.point.y - lineEnd.y) < 3
                        );
                        
                        if (!isDuplicate) {
                            connections.push({
                                point: { x: lineEnd.x, y: lineEnd.y },
                                polygonEdgeIndex: j,
                                lineSegmentIndex: line.length - 1,
                                type: 'endpoint-to-edge'
                            });
                            debug(`Line end connects to polygon edge ${j}`);
                        }
                    }
                }
            }
            
            polyPoints.forEach((vertex, idx) => {
                const startDist = Math.hypot(lineStart.x - vertex.x, lineStart.y - vertex.y);
                const endDist = Math.hypot(lineEnd.x - vertex.x, lineEnd.y - vertex.y);
                
                if (startDist < snapDistance) {
                    connections.push({
                        point: { x: lineStart.x, y: lineStart.y },
                        polygonVertexIndex: idx,
                        lineSegmentIndex: 0,
                        type: 'endpoint-to-vertex'
                    });
                    debug(`Line start connects to polygon vertex ${idx}`);
                }
                
                if (endDist < snapDistance) {
                    connections.push({
                        point: { x: lineEnd.x, y: lineEnd.y },
                        polygonVertexIndex: idx,
                        lineSegmentIndex: line.length - 1,
                        type: 'endpoint-to-vertex'
                    });
                    debug(`Line end connects to polygon vertex ${idx}`);
                }
            });
            
            return connections;
        }

        function getLineIntersection(p1, p2, p3, p4) {
            const x1 = p1.x, y1 = p1.y;
            const x2 = p2.x, y2 = p2.y;
            const x3 = p3.x, y3 = p3.y;
            const x4 = p4.x, y4 = p4.y;
            
            const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            
            if (Math.abs(denominator) < 1e-10) {
                return null;
            }
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;
            
            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                return {
                    x: x1 + t * (x2 - x1),
                    y: y1 + t * (y2 - y1)
                };
            }
            
            return null;
        }

        function createPolygonsFromLines() {
            try {
                const lineShapes = shapes.filter(s => s.type === 'line' && validateShape(s));
                if (lineShapes.length === 0) return 0;
                
                debug(`Processing ${lineShapes.length} line shapes`);
                
                let polygonsCreated = 0;
                
                const bisectionResult = handlePolygonBisections(lineShapes);
                polygonsCreated += bisectionResult.polygonsCreated;
                
                if (bisectionResult.bisections === 0) {
                    polygonsCreated += formPolygonsFromLines(lineShapes);
                }
                
                return polygonsCreated;
            } catch (error) {
                console.error('Error creating polygons from lines:', error);
                debug('Polygon creation failed: ' + error.message);
                return 0;
            }
        }

        function handlePolygonBisections(lineShapes) {
            const existingPolygons = shapes.filter(s => s.type === 'polygon' && validateShape(s));
            let bisectionsCount = 0;
            let polygonsCreated = 0;
            const processedLines = new Set();
            
            lineShapes.forEach(line => {
                if (processedLines.has(line)) return;
                
                existingPolygons.forEach(polygon => {
                    if (processedLines.has(line)) return;
                    
                    const bisectionResult = tryBisectPolygon(polygon, line);
                    if (bisectionResult && bisectionResult.length === 2) {
                        shapes = shapes.filter(s => s !== polygon);
                        shapes.push(...bisectionResult);
                        processedLines.add(line);
                        bisectionsCount++;
                        polygonsCreated += 2;
                        
                        const area1 = safeCalculateArea(bisectionResult[0].points);
                        const area2 = safeCalculateArea(bisectionResult[1].points);
                        debug(`Bisection created areas: ${Math.round(area1)}, ${Math.round(area2)}`);
                    }
                });
            });
            
            shapes = shapes.filter(shape => shape.type !== 'line' || !processedLines.has(shape));
            
            return { bisections: bisectionsCount, polygonsCreated };
        }

        function tryBisectPolygon(polygon, line) {
            debug(`Trying bisection: line has ${line.points.length} points, polygon has ${polygon.points.length} points`);
            
            const polyPoints = polygon.points.slice(0, -1);
            const cleanPolyPoints = removeDuplicatePoints(polyPoints, MIN_EDGE_INTERSECTION_DISTANCE);
            
            const lineStart = line.points[0];
            const lineEnd = line.points[line.points.length - 1];
            
            const startVertexIdx = findClosestVertex(lineStart, cleanPolyPoints);
            const endVertexIdx = findClosestVertex(lineEnd, cleanPolyPoints);
            
            if (startVertexIdx !== null && endVertexIdx !== null && startVertexIdx !== endVertexIdx) {
                debug(`Vertex-to-vertex bisection: ${startVertexIdx} to ${endVertexIdx}`);
                return splitPolygonBetweenVertices(polygon, line, startVertexIdx, endVertexIdx, cleanPolyPoints);
            }
            
            const intersections = findEdgeIntersections(line, cleanPolyPoints);
            debug(`Found ${intersections.length} edge intersections`);
            
            if (intersections.length === 2) {
                const edge1 = intersections[0].polygonEdgeIndex;
                const edge2 = intersections[1].polygonEdgeIndex;
                
                if (edge1 === edge2) {
                    debug(`Both intersections on same edge ${edge1} - this should create adjacent polygon, not bisect`);
                    return null;
                }
                
                return executeBisectionAtIntersections(polygon, line, intersections, cleanPolyPoints);
            }
            
            return null;
        }

        function findClosestVertex(point, vertices) {
            const snapDistance = getSnapDistance();
            for (let i = 0; i < vertices.length; i++) {
                const dist = Math.hypot(vertices[i].x - point.x, vertices[i].y - point.y);
                if (dist < snapDistance) {
                    return i;
                }
            }
            return null;
        }

        function findEdgeIntersections(line, polyPoints) {
            const intersections = [];
            const snapDistance = getSnapDistance();
            
            const lineStart = line.points[0];
            const lineEnd = line.points[line.points.length - 1];
            
            for (let j = 0; j < polyPoints.length; j++) {
                const polyStart = polyPoints[j];
                const polyEnd = polyPoints[(j + 1) % polyPoints.length];
                
                const startProjected = closestPointOnSegment(lineStart.x, lineStart.y, polyStart.x, polyStart.y, polyEnd.x, polyEnd.y);
                const startDistToEdge = Math.hypot(lineStart.x - startProjected.x, lineStart.y - startProjected.y);
                
                if (startDistToEdge < snapDistance) {
                    const distToPolyStart = Math.hypot(startProjected.x - polyStart.x, startProjected.y - polyStart.y);
                    const distToPolyEnd = Math.hypot(startProjected.x - polyEnd.x, startProjected.y - polyEnd.y);
                    
                    if (distToPolyStart > MIN_EDGE_INTERSECTION_DISTANCE && distToPolyEnd > MIN_EDGE_INTERSECTION_DISTANCE) {
                        intersections.push({
                            point: { x: lineStart.x, y: lineStart.y },
                            polygonEdgeIndex: j,
                            lineSegmentIndex: 0,
                            type: 'endpoint'
                        });
                        debug(`Line start snapped to edge ${j} at (${Math.round(lineStart.x)}, ${Math.round(lineStart.y)})`);
                    }
                }
            }
            
            for (let j = 0; j < polyPoints.length; j++) {
                const polyStart = polyPoints[j];
                const polyEnd = polyPoints[(j + 1) % polyPoints.length];
                
                const endProjected = closestPointOnSegment(lineEnd.x, lineEnd.y, polyStart.x, polyStart.y, polyEnd.x, polyEnd.y);
                const endDistToEdge = Math.hypot(lineEnd.x - endProjected.x, lineEnd.y - endProjected.y);
                
                if (endDistToEdge < snapDistance) {
                    const distToPolyStart = Math.hypot(endProjected.x - polyStart.x, endProjected.y - polyStart.y);
                    const distToPolyEnd = Math.hypot(endProjected.x - polyEnd.x, endProjected.y - polyEnd.y);
                    
                    if (distToPolyStart > MIN_EDGE_INTERSECTION_DISTANCE && distToPolyEnd > MIN_EDGE_INTERSECTION_DISTANCE) {
                        const isDuplicate = intersections.some(existing => 
                            Math.hypot(existing.point.x - lineEnd.x, existing.point.y - lineEnd.y) < MIN_EDGE_INTERSECTION_DISTANCE
                        );
                        
                        if (!isDuplicate) {
                            intersections.push({
                                point: { x: lineEnd.x, y: lineEnd.y },
                                polygonEdgeIndex: j,
                                lineSegmentIndex: line.points.length - 1,
                                type: 'endpoint'
                            });
                            debug(`Line end snapped to edge ${j} at (${Math.round(lineEnd.x)}, ${Math.round(lineEnd.y)})`);
                        }
                    }
                }
            }
            
            for (let i = 0; i < line.points.length - 1; i++) {
                const lineSegStart = line.points[i];
                const lineSegEnd = line.points[i + 1];
                
                for (let j = 0; j < polyPoints.length; j++) {
                    const polyStart = polyPoints[j];
                    const polyEnd = polyPoints[(j + 1) % polyPoints.length];
                    
                    const intersection = getLineIntersection(lineSegStart, lineSegEnd, polyStart, polyEnd);
                    
                    if (intersection) {
                        const distToPolyStart = Math.hypot(intersection.x - polyStart.x, intersection.y - polyStart.y);
                        const distToPolyEnd = Math.hypot(intersection.x - polyEnd.x, intersection.y - polyEnd.y);
                        
                        if (distToPolyStart > MIN_EDGE_INTERSECTION_DISTANCE && distToPolyEnd > MIN_EDGE_INTERSECTION_DISTANCE) {
                            const isDuplicate = intersections.some(existing => 
                                Math.hypot(existing.point.x - intersection.x, existing.point.y - intersection.y) < MIN_EDGE_INTERSECTION_DISTANCE
                            );
                            
                            if (!isDuplicate) {
                                intersections.push({
                                    point: intersection,
                                    polygonEdgeIndex: j,
                                    lineSegmentIndex: i,
                                    type: 'crossing'
                                });
                                debug(`Line crosses edge ${j} at (${Math.round(intersection.x)}, ${Math.round(intersection.y)})`);
                            }
                        }
                    }
                }
            }
            
            return intersections;
        }

        function splitPolygonBetweenVertices(polygon, bisectingLine, startIdx, endIdx, cleanPolyPoints) {
            if (startIdx > endIdx) {
                [startIdx, endIdx] = [endIdx, startIdx];
            }
            
            const poly1Points = [];
            for (let i = startIdx; i <= endIdx; i++) {
                poly1Points.push({ ...cleanPolyPoints[i] });
            }
            for (let i = bisectingLine.points.length - 2; i >= 1; i--) {
                poly1Points.push({ ...bisectingLine.points[i] });
            }
            
            const poly2Points = [];
            for (let i = endIdx; i !== startIdx; i = (i + 1) % cleanPolyPoints.length) {
                poly2Points.push({ ...cleanPolyPoints[i] });
                if ((i + 1) % cleanPolyPoints.length === startIdx) break;
            }
            poly2Points.push({ ...cleanPolyPoints[startIdx] });
            for (let i = 1; i < bisectingLine.points.length - 1; i++) {
                poly2Points.push({ ...bisectingLine.points[i] });
            }
            
            const cleanPoly1 = removeDuplicatePoints(poly1Points, 2);
            const cleanPoly2 = removeDuplicatePoints(poly2Points, 2);
            
            const newPolygons = [];
            
            if (cleanPoly1.length >= 3) {
                const area1 = safeCalculateArea([...cleanPoly1, cleanPoly1[0]]);
                debug(`Polygon 1 area: ${Math.round(area1)}`);
                if (area1 > MIN_POLYGON_AREA) {
                    newPolygons.push({
                        type: 'polygon',
                        points: [...cleanPoly1, cleanPoly1[0]],
                        fill: polygon.fill,
                        color: polygon.color,
                        lineStyle: polygon.lineStyle,
                        layer: polygon.layer || 'boundary'
                    });
                }
            }
            
            if (cleanPoly2.length >= 3) {
                const area2 = safeCalculateArea([...cleanPoly2, cleanPoly2[0]]);
                debug(`Polygon 2 area: ${Math.round(area2)}`);
                if (area2 > MIN_POLYGON_AREA) {
                    newPolygons.push({
                        type: 'polygon',
                        points: [...cleanPoly2, cleanPoly2[0]],
                        fill: polygon.fill,
                        color: polygon.color,
                        lineStyle: polygon.lineStyle,
                        layer: polygon.layer || 'boundary'
                    });
                }
            }
            
            if (newPolygons.length === 2) {
                const originalArea = safeCalculateArea(polygon.points);
                const totalNewArea = safeCalculateArea(newPolygons[0].points) + safeCalculateArea(newPolygons[1].points);
                debug(`Original: ${Math.round(originalArea)}, New total: ${Math.round(totalNewArea)}`);
            }
            
            return newPolygons.length === 2 ? newPolygons : null;
        }

        function executeBisectionAtIntersections(polygon, line, intersections, cleanPolyPoints) {
            const [int1, int2] = intersections.sort((a, b) => a.polygonEdgeIndex - b.polygonEdgeIndex);
            
            debug(`Bisecting between edges ${int1.polygonEdgeIndex} and ${int2.polygonEdgeIndex}`);
            
            const poly1Points = [];
            poly1Points.push({ ...int1.point });
            
            let currentIdx = (int1.polygonEdgeIndex + 1) % cleanPolyPoints.length;
            const targetIdx = (int2.polygonEdgeIndex + 1) % cleanPolyPoints.length;
            
            while (currentIdx !== targetIdx) {
                poly1Points.push({ ...cleanPolyPoints[currentIdx] });
                currentIdx = (currentIdx + 1) % cleanPolyPoints.length;
            }
            
            poly1Points.push({ ...int2.point });
            
            for (let i = line.points.length - 2; i >= 1; i--) {
                poly1Points.push({ ...line.points[i] });
            }
            
            const poly2Points = [];
            poly2Points.push({ ...int2.point });
            
            currentIdx = (int2.polygonEdgeIndex + 1) % cleanPolyPoints.length;
            const targetIdx2 = (int1.polygonEdgeIndex + 1) % cleanPolyPoints.length;
            
            while (currentIdx !== targetIdx2) {
                poly2Points.push({ ...cleanPolyPoints[currentIdx] });
                currentIdx = (currentIdx + 1) % cleanPolyPoints.length;
            }
            
            poly2Points.push({ ...int1.point });
            
            for (let i = 1; i < line.points.length - 1; i++) {
                poly2Points.push({ ...line.points[i] });
            }
            
            const cleanPoly1 = removeDuplicatePoints(poly1Points, 2);
            const cleanPoly2 = removeDuplicatePoints(poly2Points, 2);
            
            const newPolygons = [];
            
            if (cleanPoly1.length >= 3) {
                const area1 = safeCalculateArea([...cleanPoly1, cleanPoly1[0]]);
                if (area1 > MIN_POLYGON_AREA) {
                    newPolygons.push({
                        type: 'polygon',
                        points: [...cleanPoly1, cleanPoly1[0]],
                        fill: polygon.fill,
                        color: polygon.color,
                        lineStyle: polygon.lineStyle,
                        layer: polygon.layer || 'boundary'
                    });
                    debug(`Created polygon 1 with area: ${Math.round(area1)}`);
                }
            }
            
            if (cleanPoly2.length >= 3) {
                const area2 = safeCalculateArea([...cleanPoly2, cleanPoly2[0]]);
                if (area2 > MIN_POLYGON_AREA) {
                    newPolygons.push({
                        type: 'polygon',
                        points: [...cleanPoly2, cleanPoly2[0]],
                        fill: polygon.fill,
                        color: polygon.color,
                        lineStyle: polygon.lineStyle,
                        layer: polygon.layer || 'boundary'
                    });
                    debug(`Created polygon 2 with area: ${Math.round(area2)}`);
                }
            }
            
            return newPolygons.length === 2 ? newPolygons : null;
        }

        function formPolygonsFromLines(lineShapes) {
            let polygonsCreated = 0;
            const usedLines = new Set();
            
            const existingPolygons = shapes.filter(s => s.type === 'polygon' && validateShape(s));
            
            lineShapes.forEach(line => {
                if (usedLines.has(line)) return;
                
                existingPolygons.forEach(polygon => {
                    let newPolygon = tryConnectLineToPolygon(line, polygon);
                    
                    if (!newPolygon) {
                        newPolygon = tryCreateSharedEdgePolygon(line, polygon);
                    }
                    
                    if (newPolygon) {
                        shapes.push(newPolygon);
                        usedLines.add(line);
                        polygonsCreated++;
                        debug(`Created polygon via connection to existing polygon, area: ${safeCalculateArea(newPolygon.points)}`);
                    }
                });
            });
            
            const availableLines = lineShapes.filter(line => !usedLines.has(line));
            
            if (availableLines.length >= 2) {
                const connectedPolygons = findConnectedPolygons(availableLines);
                connectedPolygons.forEach(polygon => {
                    shapes.push(polygon);
                    polygon.usedLines.forEach(line => usedLines.add(line));
                    polygonsCreated++;
                });
            }
            
            shapes = shapes.filter(shape => shape.type !== 'line' || !usedLines.has(shape));
            
            return polygonsCreated;
        }

        function tryConnectLineToPolygon(line, polygon) {
            const polyPoints = polygon.points.slice(0, -1);
            const lineStart = line.points[0];
            const lineEnd = line.points[line.points.length - 1];
            
            let startVertexIdx = null;
            let endVertexIdx = null;
            const snapDistance = getSnapDistance();
            
            polyPoints.forEach((vertex, idx) => {
                if (Math.hypot(vertex.x - lineStart.x, vertex.y - lineStart.y) < snapDistance) {
                    startVertexIdx = idx;
                }
                if (Math.hypot(vertex.x - lineEnd.x, vertex.y - lineEnd.y) < snapDistance) {
                    endVertexIdx = idx;
                }
            });
            
            if (startVertexIdx !== null && endVertexIdx !== null && startVertexIdx !== endVertexIdx) {
                debug(`Line connects polygon vertices ${startVertexIdx} to ${endVertexIdx}`);
                
                const newPoints = [];
                
                let current = startVertexIdx;
                while (current !== endVertexIdx) {
                    newPoints.push({ ...polyPoints[current] });
                    current = (current + 1) % polyPoints.length;
                }
                newPoints.push({ ...polyPoints[endVertexIdx] });
                
                for (let i = line.points.length - 1; i >= 0; i--) {
                    newPoints.push({ ...line.points[i] });
                }
                
                const cleanPoints = removeDuplicatePoints(newPoints, 3);
                
                if (cleanPoints.length >= 3) {
                    const area = safeCalculateArea([...cleanPoints, cleanPoints[0]]);
                    if (area > MIN_POLYGON_AREA) {
                        debug(`Created connected polygon with area: ${Math.round(area)}`);
                        return {
                            type: 'polygon',
                            points: [...cleanPoints, cleanPoints[0]],
                            fill: polygonFill,
                            fillOpacity: polygonFillOpacity,
                            color: currentLineColor,
                            lineStyle: currentLineStyle,
                            layer: currentLayer
                        };
                    }
                }
            }
            
            return null;
        }

        function tryCreateSharedEdgePolygon(line, polygon) {
            const polyPoints = polygon.points.slice(0, -1);
            const lineStart = line.points[0];
            const lineEnd = line.points[line.points.length - 1];
            const snapDistance = getSnapDistance();
            
            debug(`Checking shared edge: line from (${Math.round(lineStart.x)}, ${Math.round(lineStart.y)}) to (${Math.round(lineEnd.x)}, ${Math.round(lineEnd.y)})`);
            
            for (let edgeIdx = 0; edgeIdx < polyPoints.length; edgeIdx++) {
                const polyStart = polyPoints[edgeIdx];
                const polyEnd = polyPoints[(edgeIdx + 1) % polyPoints.length];
                
                const startProjected = closestPointOnSegment(lineStart.x, lineStart.y, polyStart.x, polyStart.y, polyEnd.x, polyEnd.y);
                const startDistToEdge = Math.hypot(lineStart.x - startProjected.x, lineStart.y - startProjected.y);
                
                const endProjected = closestPointOnSegment(lineEnd.x, lineEnd.y, polyStart.x, polyStart.y, polyEnd.x, polyEnd.y);
                const endDistToEdge = Math.hypot(lineEnd.x - endProjected.x, lineEnd.y - endProjected.y);
                
                if (startDistToEdge < snapDistance && endDistToEdge < snapDistance) {
                    debug(`Both line endpoints on edge ${edgeIdx} - creating adjacent polygon`);
                    return createAdjacentPolygon(line, polygon, edgeIdx, polyStart, polyEnd);
                }
            }
            
            let startVertexIdx = null;
            let endEdgeInfo = null;
            
            polyPoints.forEach((vertex, idx) => {
                if (Math.hypot(vertex.x - lineStart.x, vertex.y - lineStart.y) < snapDistance) {
                    startVertexIdx = idx;
                }
            });
            
            for (let j = 0; j < polyPoints.length; j++) {
                const polyStart = polyPoints[j];
                const polyEnd = polyPoints[(j + 1) % polyPoints.length];
                
                const projected = closestPointOnSegment(lineEnd.x, lineEnd.y, polyStart.x, polyStart.y, polyEnd.x, polyEnd.y);
                const distToEdge = Math.hypot(lineEnd.x - projected.x, lineEnd.y - projected.y);
                
                if (distToEdge < snapDistance) {
                    const distToPolyStart = Math.hypot(projected.x - polyStart.x, projected.y - polyStart.y);
                    const distToPolyEnd = Math.hypot(projected.x - polyEnd.x, projected.y - polyEnd.y);
                    
                    if (distToPolyStart > MIN_EDGE_INTERSECTION_DISTANCE && distToPolyEnd > MIN_EDGE_INTERSECTION_DISTANCE) {
                        endEdgeInfo = { edgeIdx: j, point: { x: lineEnd.x, y: lineEnd.y } };
                        break;
                    }
                }
            }
            
            if (startVertexIdx !== null && endEdgeInfo !== null) {
                debug(`Line connects vertex ${startVertexIdx} to edge ${endEdgeInfo.edgeIdx}`);
                return createVertexToEdgePolygon(line, polygon, startVertexIdx, endEdgeInfo, polyPoints);
            }
            
            return null;
        }

        function createAdjacentPolygon(line, polygon, edgeIdx, polyStart, polyEnd) {
            const newPoints = [...line.points];
            const cleanPoints = removeDuplicatePoints(newPoints, 3);
            
            if (cleanPoints.length >= 3) {
                const area = safeCalculateArea([...cleanPoints, cleanPoints[0]]);
                debug(`Adjacent polygon area: ${Math.round(area)}`);
                
                if (area > MIN_POLYGON_AREA) {
                    return {
                        type: 'polygon',
                        points: [...cleanPoints, cleanPoints[0]],
                        fill: polygonFill,
                        fillOpacity: polygonFillOpacity,
                        color: currentLineColor,
                        lineStyle: currentLineStyle,
                            layer: currentLayer
                    };
                }
            }
            
            return null;
        }

        function createVertexToEdgePolygon(line, polygon, vertexIdx, edgeInfo, polyPoints) {
            const newPoints = [];
            
            newPoints.push({ ...polyPoints[vertexIdx] });
            
            for (let i = 1; i < line.points.length; i++) {
                newPoints.push({ ...line.points[i] });
            }
            
            let current = (edgeInfo.edgeIdx + 1) % polyPoints.length;
            while (current !== vertexIdx) {
                newPoints.push({ ...polyPoints[current] });
                current = (current + 1) % polyPoints.length;
            }
            
            const cleanPoints = removeDuplicatePoints(newPoints, 3);
            
            if (cleanPoints.length >= 3) {
                const area = safeCalculateArea([...cleanPoints, cleanPoints[0]]);
                debug(`Vertex-to-edge polygon area: ${Math.round(area)}`);
                
                if (area > MIN_POLYGON_AREA) {
                    return {
                        type: 'polygon',
                        points: [...cleanPoints, cleanPoints[0]],
                        fill: polygonFill,
                        fillOpacity: polygonFillOpacity,
                        color: currentLineColor,
                        lineStyle: currentLineStyle,
                            layer: currentLayer
                    };
                }
            }
            
            return null;
        }

        function findConnectedPolygons(lines) {
            const polygons = [];
            const usedLines = new Set();
            
            lines.forEach(startLine => {
                if (usedLines.has(startLine)) return;
                
                const polygon = tracePolygonFromLine(startLine, lines);
                if (polygon && polygon.points.length >= 3) {
                    polygon.usedLines.forEach(line => usedLines.add(line));
                    polygons.push({
                        type: 'polygon',
                        points: [...polygon.points, polygon.points[0]],
                        fill: polygonFill,
                        fillOpacity: polygonFillOpacity,
                        color: currentLineColor,
                        lineStyle: currentLineStyle,
                            layer: currentLayer,
                        usedLines: polygon.usedLines
                    });
                }
            });
            
            return polygons;
        }

        function tracePolygonFromLine(startLine, allLines) {
            const path = [...startLine.points];
            const usedLines = new Set([startLine]);
            const maxSteps = 10;
            const snapDistance = getSnapDistance();
            
            let currentEnd = startLine.points[startLine.points.length - 1];
            
            for (let step = 0; step < maxSteps; step++) {
                let nextLine = null;
                let useReverse = false;
                
                for (const line of allLines) {
                    if (usedLines.has(line)) continue;
                    
                    const distToStart = Math.hypot(line.points[0].x - currentEnd.x, line.points[0].y - currentEnd.y);
                    const distToEnd = Math.hypot(line.points[line.points.length - 1].x - currentEnd.x, line.points[line.points.length - 1].y - currentEnd.y);
                    
                    if (distToStart < snapDistance) {
                        nextLine = line;
                        useReverse = false;
                        break;
                    } else if (distToEnd < snapDistance) {
                        nextLine = line;
                        useReverse = true;
                        break;
                    }
                }
                
                if (!nextLine) break;
                
                const nextPoints = useReverse ? [...nextLine.points].reverse() : nextLine.points;
                
                for (let i = 1; i < nextPoints.length; i++) {
                    path.push(nextPoints[i]);
                }
                
                usedLines.add(nextLine);
                currentEnd = nextPoints[nextPoints.length - 1];
                
                const distToStart = Math.hypot(currentEnd.x - startLine.points[0].x, currentEnd.y - startLine.points[0].y);
                if (distToStart < snapDistance) {
                    const cleanPath = removeDuplicatePoints(path);
                    if (cleanPath.length >= 3 && safeCalculateArea([...cleanPath, cleanPath[0]]) > MIN_POLYGON_AREA) {
                        return { points: cleanPath, usedLines };
                    }
                }
            }
            
            return null;
        }

        function executeBisection(bisectionInfo) {
            const originalPolygon = bisectionInfo.polygon;
            const intersections = bisectionInfo.intersections.slice(0, 2);
            
            if (intersections.length !== 2) return false;
            
            const newPolygons = splitPolygon(originalPolygon, points, intersections);
            
            if (newPolygons.length === 2) {
                shapes = shapes.filter(s => s !== originalPolygon);
                shapes.push(...newPolygons);
                
                const area1 = safeCalculateArea(newPolygons[0].points);
                const area2 = safeCalculateArea(newPolygons[1].points);
                debug(`Bisection created polygons with areas: ${Math.round(area1)}, ${Math.round(area2)}`);
                
                showStatus(`Polygon bisected! New areas: ${Math.round(convertArea(area1))} ${getAreaUnit()} and ${Math.round(convertArea(area2))} ${getAreaUnit()}`);
                return true;
            }
            
            return false;
        }

        function splitPolygon(originalPolygon, bisectingLine, intersections) {
            const polyPoints = originalPolygon.points.slice(0, -1);
            // Sort intersections by polygonEdgeIndex so poly1/poly2 are constructed consistently
            const [int1, int2] = [...intersections].sort((a, b) => a.polygonEdgeIndex - b.polygonEdgeIndex);
            
            const poly1Points = [];
            const poly2Points = [];
            
            for (let i = 0; i <= int1.polygonEdgeIndex; i++) {
                poly1Points.push({ ...polyPoints[i] });
            }
            poly1Points.push({ ...int1.point });
            
            poly1Points.push(...bisectingLine.map(p => ({ ...p })));
            
            poly1Points.push({ ...int2.point });
            
            for (let i = int2.polygonEdgeIndex + 1; i < polyPoints.length; i++) {
                poly1Points.push({ ...polyPoints[i] });
            }
            
            poly2Points.push({ ...int1.point });
            for (let i = int1.polygonEdgeIndex + 1; i <= int2.polygonEdgeIndex; i++) {
                poly2Points.push({ ...polyPoints[i] });
            }
            poly2Points.push({ ...int2.point });
            poly2Points.push(...bisectingLine.slice().reverse().map(p => ({ ...p })));
            
            return [
                {
                    type: 'polygon',
                    points: [...poly1Points, poly1Points[0]],
                    fill: originalPolygon.fill,
                    color: originalPolygon.color,
                    lineStyle: originalPolygon.lineStyle
                },
                {
                    type: 'polygon', 
                    points: [...poly2Points, poly2Points[0]],
                    fill: originalPolygon.fill,
                    color: originalPolygon.color,
                    lineStyle: originalPolygon.lineStyle
                }
            ];
        }

        // FIXED: Improved flood fill function
        function floodFill(startX, startY, targetColor) {
            debug(`Paint click at (${Math.round(startX)}, ${Math.round(startY)}) with color ${targetColor}`);
            
            // IMPROVED: Better polygon selection for paint
            let targetShape = null;
            let smallestArea = Infinity;
            
            // Find the smallest polygon containing the point
            for (const shape of shapes) {
                if (shape.type === 'polygon' && validateShape(shape)) {
                    if (isPointInShape({x: startX, y: startY}, shape)) {
                        const area = safeCalculateArea(shape.points);
                        if (area > 0 && area < smallestArea) { // Ensure positive area
                            smallestArea = area;
                            targetShape = shape;
                        }
                    }
                }
            }
            
            if (targetShape) {
                saveHistoryState();
                targetShape.fill = targetColor;
                invalidateShapeCache(targetShape);
                debug(`Applied paint fill ${targetColor} to polygon with area ${Math.round(smallestArea)}`);
                requestRedraw();
                return true;
            }
            
            debug('No valid polygon found at click location for paint fill');
            return false;
        }

        // ADDITION: Edit text function for the Edit Text button
        function handleEditTextClick(x, y) {
            // 1. User-placed text labels (highest priority)
            const clickedText = findClickedText(x, y);
            if (clickedText) {
                showTextOverlay('Edit Text Label', clickedText).then(result => {
                    if (!result) return;
                    saveHistoryState();
                    Object.assign(clickedText, result);
                    showStatus('Label updated');
                    requestRedraw();
                });
                return;
            }

            // 2. Polygon area sub-labels ("Lot Area" / "Feature" / custom)
            const clickedLabel = findClickedLabel(x, y);
            if (clickedLabel) {
                const shape = clickedLabel.shape;
                const isFeature = (shape.layer || 'boundary') === 'feature';
                const current = (shape.areaSubLabel !== undefined)
                    ? shape.areaSubLabel
                    : (isFeature ? 'Feature' : 'Lot Area');
                showSimpleTextOverlay('Edit area sub-label (leave empty to hide)', current).then(newText => {
                    if (newText === null) return;
                    saveHistoryState();
                    shape.areaSubLabel = newText; // '' = intentionally hidden
                    invalidateShapeCache(shape);
                    showStatus(newText ? 'Sub-label updated' : 'Sub-label hidden');
                    requestRedraw();
                });
                return;
            }

            // 3. Measurement edge labels â€” clicking one in editText mode asks to hide/delete it
            const clickedDist = findClickedDistance(x, y);
            if (clickedDist) {
                // For measure-tool lines: delete the whole line
                if (clickedDist.shape && clickedDist.shape.type === 'measure' && clickedDist.edgeIndex === undefined) {
                    if (confirm('Delete this measurement line?')) {
                        saveHistoryState();
                        distancePositions.delete(clickedDist.shape);
                        shapes = shapes.filter(s => s !== clickedDist.shape);
                        showStatus('Measurement deleted');
                        requestRedraw();
                    }
                    return;
                }
                // Edge dimension labels: no hide in editText mode
                showStatus('Switch to Select mode to move this label');
                return;
            }

            showStatus('Click on an area label, text label, or dimension number to edit/delete');
        }

        function handleTextClick(x, y) {
            showTextOverlay('Add Text Label').then(result => {
                if (!result) return;
                saveHistoryState();
                textLabels.push({ x, y, id: Date.now() + Math.random(), ...result });
                requestRedraw();
            });
        }

        function findClickedText(x, y) {
            let clicked = null;
            textLabels.forEach(tl => { const b=getTextBounds(tl); if(x>=b.x&&x<=b.x+b.w&&y>=b.y&&y<=b.y+b.h) clicked=tl; });
            return clicked;
        }

        function saveHistoryState() {
            if (_historyRestoring) return;
            history = history.slice(0, historyIndex + 1);

            // Stamp IDs on all shapes NOW, before serializing, so the serialized
            // shapes array contains the same IDs that serializePositionMap will use.
            shapes.forEach(s => ensureShapeId(s));

            function serializePositionMap(map) {
                const entries = [];
                map.forEach((value, key) => {
                    const k = (typeof key === 'string') ? key : `__sid_${ensureShapeId(key)}`;
                    entries.push([k, value]);
                });
                return entries;
            }

            const state = {
                shapes: JSON.parse(JSON.stringify(shapes)),
                textLabels: JSON.parse(JSON.stringify(textLabels)),
                imageTransform: JSON.parse(JSON.stringify(imageTransform)),
                labelPositions:    serializePositionMap(labelPositions),
                distancePositions: serializePositionMap(distancePositions),
                labelColors:       serializePositionMap(labelColors)
            };
            history.push(state);
            historyIndex++;
            if (history.length > 50) { history.shift(); historyIndex--; }
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(history[historyIndex]);
                showStatus('Undo (' + historyIndex + ' remaining)');
                debug('Undo applied, index=' + historyIndex);
            } else {
                showStatus('Nothing left to undo');
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState(history[historyIndex]);
                showStatus('Redo');
                debug('Redo applied, index=' + historyIndex);
            } else {
                showStatus('Nothing to redo');
            }
        }

        function restoreState(state) {
            _historyRestoring = true;
            shapes     = JSON.parse(JSON.stringify(state.shapes));
            textLabels = JSON.parse(JSON.stringify(state.textLabels || []));
            if (state.imageTransform) imageTransform = JSON.parse(JSON.stringify(state.imageTransform));

            // Pre-stamp IDs so we can match serialized __sid_N keys back to shape objects
            shapes.forEach(s => { if (!s.id) s.id = newShapeId(); });
            const shapeById = {};
            shapes.forEach(s => { shapeById[s.id] = s; });

            function rebuildMap(entries) {
                const m = new Map();
                if (!Array.isArray(entries)) return m;
                entries.forEach(([k, v]) => {
                    if (typeof k === 'string' && k.startsWith('__sid_')) {
                        const id = parseInt(k.replace('__sid_', ''), 10);
                        const obj = shapeById[id];
                        if (obj) m.set(obj, v);
                    } else {
                        m.set(k, v);
                    }
                });
                return m;
            }

            labelPositions    = rebuildMap(state.labelPositions);
            distancePositions = rebuildMap(state.distancePositions);
            labelColors = state.labelColors ? rebuildMap(state.labelColors) : new Map();
            shapeCache.clear();
            _historyRestoring = false;
            requestRedraw();
        }

        // â”€â”€ Inline text input (replaces blocking prompt()) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Returns a Promise that resolves with the string entered, or null on cancel.
        function showSimpleTextOverlay(labelText, defaultValue) {
            // Simple single-line text input â€” used for area sub-labels, confirmations etc.
            return new Promise(resolve => {
                const overlay   = document.getElementById('textOverlay');
                const textarea  = document.getElementById('textOverlayInput');
                const lbl       = document.getElementById('textOverlayLabel');
                const ok        = document.getElementById('textOverlayOk');
                const cancel    = document.getElementById('textOverlayCancel');
                // Hide formatting controls, show only textarea
                const fmtRow = document.getElementById('txtFmtRow');
                const preview = document.getElementById('txtPreview');
                const hint    = document.getElementById('txtHint');
                fmtRow.style.display  = 'none';
                preview.style.display = 'none';
                hint.style.display    = 'none';
                textarea.style.fontFamily = 'Arial,sans-serif';
                lbl.textContent    = labelText || 'Enter text';
                textarea.value     = defaultValue || '';
                ok.textContent     = 'OK';
                overlay.style.display = 'block';
                setTimeout(() => { textarea.focus(); textarea.select(); }, 40);
                function finish(v) {
                    overlay.style.display = 'none';
                    textarea.blur();
                    // Restore formatting controls
                    fmtRow.style.display  = '';
                    preview.style.display = '';
                    hint.style.display    = '';
                    cleanup(); resolve(v);
                }
                function onOk()     { finish(textarea.value); }
                function onCancel() { finish(null); }
                function onKey(e) {
                    if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); onOk(); }
                    if (e.key === 'Escape') { e.preventDefault(); onCancel(); }
                }
                function cleanup() {
                    ok.removeEventListener('click', onOk);
                    cancel.removeEventListener('click', onCancel);
                    textarea.removeEventListener('keydown', onKey);
                    document.getElementById('textOverlayBg').removeEventListener('click', onCancel);
                }
                ok.addEventListener('click', onOk);
                cancel.addEventListener('click', onCancel);
                textarea.addEventListener('keydown', onKey);
                document.getElementById('textOverlayBg').addEventListener('click', onCancel);
            });
        }

        function showTextOverlay(labelText, existing) {
            return new Promise(resolve => {
                const ov=document.getElementById('textOverlay'), ta=document.getElementById('textOverlayInput'),
                    lbl=document.getElementById('textOverlayLabel'), ok=document.getElementById('textOverlayOk'),
                    cancel=document.getElementById('textOverlayCancel'), sf=document.getElementById('txtFont'),
                    ss=document.getElementById('txtSize'), bb=document.getElementById('txtBold'),
                    bi=document.getElementById('txtItalic'), sa=document.getElementById('txtAlign'),
                    sc=document.getElementById('txtColor'), pv=document.getElementById('txtPreview');
                lbl.textContent = labelText || 'Add Text Label';
                ta.value  = existing ? existing.text  : '';
                sf.value  = existing ? (existing.font  || 'Arial')  : 'Arial';
                const sv  = String(existing ? (existing.size || 14) : 14);
                [...ss.options].forEach(o => o.selected = o.value === sv);
                sa.value  = existing ? (existing.align || 'left')   : 'left';
                sc.value  = existing ? (existing.color || 'black')  : (currentLineColor || 'black');
                let bold=!!(existing&&existing.bold), italic=!!(existing&&existing.italic);
                const BI_OFF = { background:'#eef3fa', color:'#1a5fa0', border:'1px solid #a8c0da' };
                const BI_ON  = { background:'#1a5fa0', color:'#ffffff', border:'1px solid #4a90d0' };
                function applyBIStyle(btn, on) { Object.assign(btn.style, on ? BI_ON : BI_OFF); }
                applyBIStyle(bb, bold); applyBIStyle(bi, italic);
                ok.textContent = existing ? 'Update' : 'Place Text';
                ov.style.display = 'block';
                setTimeout(() => ta.focus(), 40);
                const CH = {black:'#000',red:'#DC143C',blue:'#1E90FF',green:'#228B22',brown:'#8B4513',gray:'#808080',purple:'#6611dd'};
                function upPrev() {
                    pv.style.font = (italic?'italic ':'')+(bold?'bold ':'')+ss.value+'px '+sf.value;
                    pv.style.color = CH[sc.value]||'#000'; pv.style.textAlign = sa.value;
                    pv.textContent = ta.value || 'Previewâ€¦';
                }
                bb.onclick = () => { bold=!bold; applyBIStyle(bb, bold); upPrev(); };
                bi.onclick = () => { italic=!italic; applyBIStyle(bi, italic); upPrev(); };
                const els=[ta,sf,ss,sa,sc]; els.forEach(e=>e.addEventListener('input',upPrev)); upPrev();
                function res(v){ov.style.display='none';ta.blur();cleanup();resolve(v);}
                function onOk(){
                    const t=ta.value.trim(); if(!t){res(null);return;}
                    res({text:t,font:sf.value,size:parseInt(ss.value)||14,bold,italic,align:sa.value,color:sc.value});
                }
                function onCancel(){res(null);}
                function onKey(e){if(e.key==='Enter'&&!e.shiftKey){e.preventDefault();onOk();}if(e.key==='Escape'){e.preventDefault();onCancel();}}
                function cleanup(){
                    ok.removeEventListener('click',onOk); cancel.removeEventListener('click',onCancel);
                    ta.removeEventListener('keydown',onKey);
                    document.getElementById('textOverlayBg').removeEventListener('click',onCancel);
                    els.forEach(e=>e.removeEventListener('input',upPrev)); bb.onclick=null; bi.onclick=null;
                }
                ok.addEventListener('click',onOk); cancel.addEventListener('click',onCancel);
                ta.addEventListener('keydown',onKey);
                document.getElementById('textOverlayBg').addEventListener('click',onCancel);
            });
        }

        function calculateTotalArea(polygon) {
            if (!polygon || polygon.type !== 'polygon') return 0;
            
            const baseArea = safeCalculateArea(polygon.points);
            
            // Boundary polygons: subtract only other boundary polygons that sit inside them
            // (hole-in-lot semantics).
            // Feature polygons (buildings, driveways): never subtracted from anything;
            // they show their own raw area independently.
            if ((polygon.layer || 'boundary') === 'feature') {
                return Math.max(0, baseArea);
            }

            let subtractedArea = 0;
            shapes.forEach(otherShape => {
                if (otherShape !== polygon &&
                    otherShape.type === 'polygon' &&
                    (otherShape.layer || 'boundary') === 'boundary') {
                    if (isPolygonCompletelyInside(otherShape, polygon)) {
                        subtractedArea += safeCalculateArea(otherShape.points);
                    }
                }
            });
            
            return Math.max(0, baseArea - subtractedArea);
        }

        function isPolygonCompletelyInside(innerPoly, outerPoly) {
            if (!innerPoly || !outerPoly || innerPoly === outerPoly) return false;
            
            for (let i = 0; i < innerPoly.points.length - 1; i++) {
                if (!isPointInShape(innerPoly.points[i], outerPoly)) {
                    return false;
                }
            }
            return true;
        }

        function getShapeCache(shape) {
            if (!shapeCache.has(shape)) {
                const cache = {};
                if (shape.type === 'polygon') {
                    cache.area = safeCalculateArea(shape.points);
                    cache.centroid = calculateCentroid(shape.points);
                }
                shapeCache.set(shape, cache);
            }
            return shapeCache.get(shape);
        }

        function invalidateShapeCache(shape) {
            shapeCache.delete(shape);
        }

        function findBestLabelPosition(polygon, centroid) {
            const bounds = getPolygonBounds(polygon.points);

            if (!isPointInShape(centroid, polygon)) {
                centroid = {
                    x: (bounds.minX + bounds.maxX) / 2,
                    y: (bounds.minY + bounds.maxY) / 2
                };
            }

            // Candidate positions spread across the polygon interior
            const w = bounds.maxX - bounds.minX;
            const h = bounds.maxY - bounds.minY;
            const testPositions = [
                centroid,
                { x: centroid.x, y: centroid.y - h * 0.15 },
                { x: centroid.x, y: centroid.y + h * 0.15 },
                { x: centroid.x - w * 0.15, y: centroid.y },
                { x: centroid.x + w * 0.15, y: centroid.y },
                { x: bounds.minX + w * 0.25, y: bounds.minY + h * 0.25 },
                { x: bounds.minX + w * 0.75, y: bounds.minY + h * 0.25 },
                { x: bounds.minX + w * 0.25, y: bounds.minY + h * 0.75 },
                { x: bounds.minX + w * 0.75, y: bounds.minY + h * 0.75 },
                { x: bounds.minX + w * 0.5,  y: bounds.minY + h * 0.25 },
                { x: bounds.minX + w * 0.5,  y: bounds.minY + h * 0.75 },
            ];

            // Approximate pixel size of a label (in world units) so we can check real overlap
            const labelW = 60 / zoom;
            const labelH = 24 / zoom;

            // Collect already-resolved positions for all OTHER polygons (use labelPositions if set)
            const occupiedRects = [];
            for (const other of shapes) {
                if (other === polygon || other.type !== 'polygon') continue;
                const otherCache = getShapeCache(other);
                const otherPos = labelPositions.get(other) || otherCache.centroid;
                occupiedRects.push({
                    x: otherPos.x - labelW / 2,
                    y: otherPos.y - labelH / 2,
                    w: labelW, h: labelH
                });
            }

            function overlapsAny(pos) {
                const lx = pos.x - labelW / 2, ly = pos.y - labelH / 2;
                for (const r of occupiedRects) {
                    if (lx < r.x + r.w && lx + labelW > r.x &&
                        ly < r.y + r.h && ly + labelH > r.y) return true;
                }
                return false;
            }

            for (const testPos of testPositions) {
                if (!isPointInShape(testPos, polygon)) continue;
                if (!overlapsAny(testPos)) return testPos;
            }

            // All candidates overlap â€” return the centroid as fallback
            return centroid;
        }

        function getPolygonBounds(points) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            points.forEach(point => {
                minX = Math.min(minX, point.x);
                maxX = Math.max(maxX, point.x);
                minY = Math.min(minY, point.y);
                maxY = Math.max(maxY, point.y);
            });
            
            return { minX, maxX, minY, maxY };
        }

        function findClosestPoint(x, y) {
            const POINT_SELECT_DISTANCE = 8 / zoom;
            let closestPoint = null;
            let minDistance = POINT_SELECT_DISTANCE;
            
            shapes.forEach(shape => {
                // Skip line shapes â€” they're selected as a whole, not point-by-point
                if (shape.type === 'line') return;
                shape.points.forEach(point => {
                    const dist = Math.hypot(x - point.x, y - point.y);
                    if (dist < minDistance) {
                        minDistance = dist;
                        closestPoint = point;
                    }
                });
            });
            
            return closestPoint;
        }

        function findClosestEdge(x, y) {
            const EDGE_SELECT_DISTANCE = 5 / zoom;
            let closestEdge = null;
            let minDistance = EDGE_SELECT_DISTANCE;
            
            shapes.forEach(shape => {
                // Only match polygon edges â€” line shapes are selected as a whole via isClickNearShape
                if (shape.type === 'polygon') {
                    for (let i = 0; i < shape.points.length - 1; i++) {
                        const p1 = shape.points[i];
                        const p2 = shape.points[i + 1];
                        const projected = closestPointOnSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                        const dist = Math.hypot(x - projected.x, y - projected.y);
                        
                        if (dist < minDistance) {
                            minDistance = dist;
                            closestEdge = {
                                shape: shape,
                                startIndex: i,
                                endIndex: i + 1,
                                startPoint: p1,
                                endPoint: p2
                            };
                        }
                    }
                }
            });
            
            return closestEdge;
        }

        // ADDITION: Function to find clicked measurement lines for selection/deletion
        function findClickedMeasurement(x, y) {
            const MEASUREMENT_CLICK_DISTANCE = 20 / zoom; // generous â€” dim line is offset from points
            let clickedMeasurement = null;
            let minDistance = MEASUREMENT_CLICK_DISTANCE;
            
            shapes.forEach(shape => {
                if (shape.type === 'measure' && shape.points.length === 2) {
                    const p1 = shape.points[0];
                    const p2 = shape.points[1];
                    
                    // Check both the original segment AND the offset dimension line
                    const projected = closestPointOnSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                    const dist = Math.hypot(x - projected.x, y - projected.y);
                    
                    if (dist < minDistance) {
                        minDistance = dist;
                        clickedMeasurement = shape;
                    }
                }
            });
            
            return clickedMeasurement;
        }
        function findClickedDistance(x, y) {
            const DISTANCE_CLICK_DISTANCE = 12 / zoom; // Click tolerance for distance labels
            let clickedDistance = null;
            
            shapes.forEach(shape => {
                if (shape.type === 'measure' && shape.points.length === 2) {
                    const p1 = shape.points[0], p2 = shape.points[1];
                    const midX = (p1.x + p2.x) / 2;
                    const midY = (p1.y + p2.y) / 2;
                    
                    // Default position matches drawShape: offset perpendicular to the line
                    let defaultPos;
                    const dlen = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                    if (dlen > 0.001) {
                        const nx = -(p2.y - p1.y) / dlen;
                        const ny =  (p2.x - p1.x) / dlen;
                        defaultPos = { x: midX + nx * 8 / zoom, y: midY + ny * 8 / zoom };
                    } else {
                        defaultPos = { x: midX, y: midY - 8 / zoom };
                    }
                    
                    const labelPos = distancePositions.get(shape) || defaultPos;
                    const dist = Math.hypot(x - labelPos.x, y - labelPos.y);
                    if (dist < DISTANCE_CLICK_DISTANCE) {
                        clickedDistance = { shape: shape, position: labelPos };
                    }
                }
                
                // Also check edge measurements on polygons and lines
                if (shape.type === 'polygon' || shape.type === 'line') {
                    const edgeCount = shape.type === 'polygon' ? shape.points.length - 1 : shape.points.length - 1;
                    
                    for (let i = 0; i < edgeCount; i++) {
                        const p1 = shape.points[i];
                        const p2 = shape.points[i + 1];
                        
                        if (Math.hypot(p2.x - p1.x, p2.y - p1.y) < 1) continue;
                        
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        
                        const edgeKey = `${ensureShapeId(shape)}_edge_${i}`;
                        const labelPos = distancePositions.get(edgeKey) || { x: midX, y: midY - 8 / zoom };
                        
                        const dist = Math.hypot(x - labelPos.x, y - labelPos.y);
                        if (dist < DISTANCE_CLICK_DISTANCE) {
                            clickedDistance = { shape: shape, edgeIndex: i, position: labelPos, key: edgeKey };
                        }
                    }
                }
            });
            
            return clickedDistance;
        }
        function findClickedLabel(x, y) {
            const LABEL_CLICK_DISTANCE = 12 / zoom; // Click tolerance for labels
            let clickedLabel = null;
            
            shapes.forEach(shape => {
                if (shape.type === 'polygon') {
                    const cache = getShapeCache(shape);
                    const labelPos = labelPositions.get(shape) || findBestLabelPosition(shape, cache.centroid);
                    
                    const dist = Math.hypot(x - labelPos.x, y - labelPos.y);
                    if (dist < LABEL_CLICK_DISTANCE) {
                        clickedLabel = { shape: shape, position: labelPos };
                    }
                }
            });
            
            return clickedLabel;
        }

        function handleDrawClick(x, y, snapResult) {
            if (points.length === 0) {
                saveHistoryState();
            }
            
            const newPoint = { x, y };
            points.push(newPoint);
            debug(`Added point ${points.length}: (${Math.round(x)}, ${Math.round(y)})`);

            if (points.length >= 3 && snapResult && snapResult.isFirstPoint) {
                completePolygon();
                return;
            }
            
            if (points.length >= 2) {
                bisectionTarget = checkForBisection();
            }
            updateDrawCounter();
        }

        function handleSelectClick(x, y, ctrlKey) {
            // ADDITION: Check if user clicked on a text label for moving (like area labels)
            const clickedText = findClickedText(x, y);
            
            // Handle text moving mode (same as area labels)
            if (textMoveMode && selectedText) {
                // Drop the text at new position
                saveHistoryState();
                selectedText.x = x;
                selectedText.y = y;
                selectedText = null;
                textMoveMode = false;
                debug('Text label dropped at new position');
                requestRedraw();
                return;
            }
            
            // â”€â”€ Drop modes â€” if we're mid-drag, this click drops the item â”€â”€â”€â”€â”€â”€
            if (distanceMoveMode && selectedDistance) {
                saveHistoryState();
                if (selectedDistance.edgeIndex !== undefined) {
                    distancePositions.set(selectedDistance.key, { x, y });
                } else {
                    distancePositions.set(selectedDistance.shape, { x, y });
                }
                selectedDistance = null; distanceMoveMode = false;
                requestRedraw(); return;
            }
            if (labelMoveMode && selectedLabel) {
                saveHistoryState();
                labelPositions.set(selectedLabel.shape, { x, y });
                selectedLabel = null; labelMoveMode = false;
                requestRedraw(); return;
            }

            // â”€â”€ LINE + MEASURE shape selection (both selectable as whole shapes) â”€
            // Labels take priority â€” if a label is nearby, skip line selection
            const _labelGuard = findClickedDistance(x, y) || findClickedLabel(x, y) || findClickedText(x, y);
            let nearbyShape = null;
            let nearbyDist = Infinity;
            if (!_labelGuard) shapes.forEach(s => {
                if (s.type !== 'line' && s.type !== 'measure') return;
                for (let i = 0; i < s.points.length - 1; i++) {
                    const proj = closestPointOnSegment(x, y, s.points[i].x, s.points[i].y, s.points[i+1].x, s.points[i+1].y);
                    const d = Math.hypot(x - proj.x, y - proj.y);
                    if (d < nearbyDist && d <= 14 / zoom) {
                        nearbyDist = d;
                        nearbyShape = s;
                    }
                }
            });
            if (nearbyShape) {
                const sel = nearbyShape;
                if (ctrlKey) {
                    if (selectedShapes.has(sel)) { selectedShapes.delete(sel); }
                    else { selectedShapes.add(sel); selectedShape = sel; }
                    showStatus(`${selectedShapes.size} shape(s) selected â€” click Color or Style to change all`);
                } else {
                    selectedShapes = new Set([sel]);
                    selectedShape = sel;
                    showStatus('Selected â€” click Color or Style to change Â· Ctrl+click to add more Â· Del to delete');
                }
                // Sync toolbar to this shape's current style/colour
                currentLineStyle = sel.lineStyle || 'thin'; updateLineStyleBtn();
                const ci = COLOR_CYCLE.indexOf(sel.color);
                if (ci >= 0) { colorIndex = ci; currentLineColor = sel.color; updateColorBtn(); }
                // Also set selectedMeasurement so Delete key still works on measure shapes
                selectedMeasurement = (sel.type === 'measure') ? sel : null;
                selectedPoint = null; selectedEdge = null;
                selectedLabel = null; labelMoveMode = false;
                selectedText = null; textMoveMode = false;
                selectedDistance = null; distanceMoveMode = false;
                dragStart = null;
                requestRedraw(); return;
            }

            // â”€â”€ Label / text pickups â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const clickedDistance = findClickedDistance(x, y);
            const clickedLabel    = findClickedLabel(x, y);

            if (clickedText) {
                selectedText = clickedText; textMoveMode = true;
                selectedShape = null; selectedShapes = new Set(); selectedPolygonForFill = null;
                selectedPoint = null; selectedEdge = null;
                // sync colour button
                { const _ci = COLOR_CYCLE.indexOf(clickedText.color); if (_ci >= 0) { colorIndex = _ci; currentLineColor = clickedText.color; updateColorBtn(); } }
                showStatus('Text label selected â€” click Color to change Â· click canvas to place');
                selectedLabel = null; labelMoveMode = false;
                selectedDistance = null; distanceMoveMode = false; selectedMeasurement = null; dragStart = null;
                requestRedraw(); return;
            }
            if (clickedDistance) {
                selectedDistance = clickedDistance; distanceMoveMode = true;
                selectedShape = null; selectedShapes = new Set(); selectedPolygonForFill = null;
                selectedPoint = null; selectedEdge = null;
                selectedLabel = null; labelMoveMode = false;
                selectedText = null; textMoveMode = false; selectedMeasurement = null; dragStart = null;
                showStatus('Label selected â€” click Color to change colour Â· click canvas to place');
                requestRedraw(); return;
            }

            // (measure shapes handled in nearbyShape block above)

            if (clickedLabel) {
                selectedLabel = clickedLabel; labelMoveMode = true;
                selectedShape = null; selectedShapes = new Set(); selectedPolygonForFill = null;
                selectedPoint = null; selectedEdge = null;
                { const _ac = clickedLabel.shape.areaLabelColor; if (_ac) { const _ci = COLOR_CYCLE.indexOf(_ac); if (_ci >= 0) { colorIndex = _ci; currentLineColor = _ac; updateColorBtn(); } } }
                showStatus('Area label selected â€” click Color to change Â· click canvas to place');
                selectedText = null; textMoveMode = false;
                selectedDistance = null; distanceMoveMode = false; selectedMeasurement = null; dragStart = null;
                requestRedraw(); return;
            }

            // â”€â”€ Polygon point / edge / body â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const clickedPoint = findClosestPoint(x, y);
            if (selectedPoint && clickedPoint === selectedPoint) {
                selectedPoint = null; dragStart = null;
                requestRedraw(); return;
            }
            if (clickedPoint) {
                saveHistoryState();
                selectedPoint = clickedPoint; dragStart = { x, y };
                selectedShape = null; selectedShapes = new Set(); selectedEdge = null;
                selectedLabel = null; labelMoveMode = false;
                selectedText = null; textMoveMode = false;
                selectedDistance = null; distanceMoveMode = false; selectedMeasurement = null;
                requestRedraw(); return;
            }

            const clickedEdge = findClosestEdge(x, y);
            if (clickedEdge) {
                selectedEdge = clickedEdge;
                // Also select the parent polygon so style/colour changes apply
                selectedShape = clickedEdge.shape;
                selectedShapes = new Set([clickedEdge.shape]);
                selectedPolygonForFill = clickedEdge.shape;
                // Sync toolbar to this shape's current style/colour
                currentLineStyle = clickedEdge.shape.lineStyle || 'thin'; updateLineStyleBtn();
                const _eci = COLOR_CYCLE.indexOf(clickedEdge.shape.color);
                if (_eci >= 0) { colorIndex = _eci; currentLineColor = clickedEdge.shape.color; updateColorBtn(); }
                selectedPoint = null;
                selectedLabel = null; labelMoveMode = false;
                selectedText = null; textMoveMode = false;
                selectedDistance = null; distanceMoveMode = false; selectedMeasurement = null;
                requestRedraw(); return;
            }

            const clickedPolygon = shapes.find(s => s.type === 'polygon' && isClickNearShape(x, y, s));
            if (clickedPolygon) {
                if (ctrlKey) {
                    if (selectedShapes.has(clickedPolygon)) { selectedShapes.delete(clickedPolygon); if (selectedShape === clickedPolygon) selectedShape = [...selectedShapes].slice(-1)[0] || null; }
                    else { selectedShapes.add(clickedPolygon); selectedShape = clickedPolygon; }
                } else {
                    selectedShapes = new Set([clickedPolygon]);
                    selectedShape = clickedPolygon;
                }
                selectedPolygonForFill = clickedPolygon;
                // Sync toolbar
                currentLineStyle = clickedPolygon.lineStyle || 'thin'; updateLineStyleBtn();
                const ci2 = COLOR_CYCLE.indexOf(clickedPolygon.color);
                if (ci2 >= 0) { colorIndex = ci2; currentLineColor = clickedPolygon.color; updateColorBtn(); }
                selectedPoint = null; selectedEdge = null; selectedMeasurement = null;
                selectedLabel = null; labelMoveMode = false;
                selectedText = null; textMoveMode = false;
                selectedDistance = null; distanceMoveMode = false; dragStart = null;
                requestRedraw(); return;
            }

            // â”€â”€ Empty space click: deselect â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (!ctrlKey) {
                selectedShape = null;
                selectedShapes = new Set();
                selectedPolygonForFill = null;
            }
        }

        // ENHANCED: Improved measure click handler with preview support
        function handleMeasureClick(x, y) {
            measurePoints.push({ x, y });
            if (measurePoints.length === 1) {
                updateDrawCounter();
            }
            if (measurePoints.length === 2) {
                let distance;
                let measureType = 'direct';
                
                // Check if this was a perpendicular measurement
                if (currentSnapInfo && currentSnapInfo.type === 'perpendicular') {
                    distance = currentSnapInfo.distance * scale;
                    measureType = 'perpendicular';
                    debug(`Perpendicular measurement: ${distance.toFixed(2)} ft`);
                } else {
                    distance = Math.hypot(
                        measurePoints[1].x - measurePoints[0].x,
                        measurePoints[1].y - measurePoints[0].y
                    ) * scale;
                    debug(`Direct measurement: ${distance.toFixed(2)} ft`);
                }
                
                shapes.push({ 
                    type: 'measure', 
                    points: [...measurePoints], 
                    color: 'purple',
                    lineStyle: currentLineStyle,
                    distance: distance,
                    measureType: measureType
                });
                
                showStatus(`${measureType === 'perpendicular' ? 'Perpendicular ' : ''}Distance: ${convertDistance(distance).toFixed(2)} ${getDistanceUnit()}`);
                measurePoints = [];
                measurePreviewInfo = null;
                previewPoint = null;
                currentSnapInfo = null;
                updateModeButtons(); // reset hint bar
            }
        }

        function handlePaintClick(x, y) {
            debug(`Paint mode click at (${Math.round(x)}, ${Math.round(y)})`);
            floodFill(x, y, paintColor);
        }

        function handleSelectMouseMove(x, y) {
            if (selectedPoint && dragStart) {
                const dx = x - dragStart.x;
                const dy = y - dragStart.y;
                
                selectedPoint.x += dx;
                selectedPoint.y += dy;
                
                shapes.forEach(shape => {
                    if (shape.points.includes(selectedPoint)) {
                        invalidateShapeCache(shape);
                    }
                });
                
                dragStart = { x, y };
            }
        }

        function completePolygon() {
            const polygon = {
                type: 'polygon',
                points: [...points, points[0]],
                fill: polygonFill,
                fillOpacity: polygonFillOpacity,
                color: currentLineColor,
                lineStyle: currentLineStyle,
                layer: currentLayer
            };
            shapes.push(polygon);
            
            const area = safeCalculateArea(polygon.points);
            debug(`Created continuous polygon, area: ${Math.round(area)}`);
            showStatus(`Polygon completed! Area: ${Math.round(convertArea(area))} ${getAreaUnit()}`);
            
            resetDrawingState();
        }

        function resetDrawingState() {
            points = [];
            previewPoint = null;
            bisectionTarget = null;
            measurePreviewInfo = null;
            updateModeButtons(); // refreshes hint bar
        }

        // ENHANCED: Updated snap color function
        function getSnapColor(snapType) {
            switch(snapType) {
                case 'horizontal': 
                case 'vertical': return 'cyan';
                case 'alignmentConstraint': return 'lightblue';
                case 'constrainedEndpoint': return 'lime';
                case 'constrainedEdge': return 'orange';
                case 'edge': return 'yellow';
                case 'endpoint': return 'red';
                case 'firstPoint': return 'lime';
                case 'rectangleCorner': return 'magenta';
                case 'perpendicular': return 'hotpink'; // New color for perpendicular snaps
                default: return 'orange';
            }
        }

        function drawAlignmentGuides(guides) {
            if (!guides || guides.length === 0) return;
            
            ctx.save();
            ctx.strokeStyle = 'lightblue';
            ctx.lineWidth = 1 / zoom;
            ctx.setLineDash([2 / zoom, 4 / zoom]);
            ctx.globalAlpha = 0.4;
            
            const canvasWidth = canvas.width / zoom;
            const canvasHeight = canvas.height / zoom;
            const viewLeft = -offsetX / zoom;
            const viewRight = canvasWidth - offsetX / zoom;
            const viewTop = -offsetY / zoom;
            const viewBottom = canvasHeight - offsetY / zoom;
            
            guides.forEach(guide => {
                if (guide.type === 'horizontal') {
                    ctx.beginPath();
                    ctx.moveTo(viewLeft, guide.y);
                    ctx.lineTo(viewRight, guide.y);
                    ctx.stroke();
                    
                    ctx.save();
                    ctx.fillStyle = 'lightblue';
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(guide.alignPoint.x, guide.alignPoint.y, 3 / zoom, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();
                } else if (guide.type === 'vertical') {
                    ctx.beginPath();
                    ctx.moveTo(guide.x, viewTop);
                    ctx.lineTo(guide.x, viewBottom);
                    ctx.stroke();
                    
                    ctx.save();
                    ctx.fillStyle = 'lightblue';
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(guide.alignPoint.x, guide.alignPoint.y, 3 / zoom, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();
                }
            });
            
            ctx.restore();
        }

        // ENHANCED: Improved preview drawing with perpendicular support
        function drawPreviewElements() {
            // Only show preview/snap indicators when actively drawing or measuring
            if (mode !== 'draw' && mode !== 'measure') return;
            if (!previewPoint) return;
            
            if (currentSnapInfo && currentSnapInfo.alignmentGuides && currentSnapInfo.type !== 'edge') {
                drawAlignmentGuides(currentSnapInfo.alignmentGuides);
            }
            
            ctx.save();
            
            if (currentSnapInfo && currentSnapInfo.type !== 'none') {
                const color = getSnapColor(currentSnapInfo.type);
                
                let radius = currentSnapInfo.type === 'edge' ? 8 / zoom : 6 / zoom;
                if (currentSnapInfo.type === 'perpendicular') {
                    radius = 10 / zoom; // Larger for perpendicular snaps
                }
                
                ctx.beginPath();
                ctx.arc(previewPoint.x, previewPoint.y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(previewPoint.x, previewPoint.y, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2 / zoom;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(previewPoint.x, previewPoint.y, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = color;
                ctx.lineWidth = 1 / zoom;
                ctx.stroke();
                
                // Special indicator for perpendicular snaps
                if (currentSnapInfo.type === 'perpendicular') {
                    ctx.save();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3 / zoom;
                    const size = 6 / zoom;
                    ctx.beginPath();
                    ctx.moveTo(previewPoint.x - size, previewPoint.y - size);
                    ctx.lineTo(previewPoint.x + size, previewPoint.y - size);
                    ctx.lineTo(previewPoint.x + size, previewPoint.y + size);
                    ctx.stroke();
                    ctx.restore();
                }
                
            } else {
                ctx.beginPath();
                ctx.arc(previewPoint.x, previewPoint.y, 3 / zoom, 0, 2 * Math.PI);
                ctx.fillStyle = 'orange';
                ctx.fill();
            }
            ctx.restore();
            
            // Edge distance indicators (shown when snapping onto a line segment)
            const snapHasEdge = currentSnapInfo && 
                (currentSnapInfo.type === 'edge' || currentSnapInfo.type === 'constrainedEdge') &&
                currentSnapInfo.edgeStart && currentSnapInfo.edgeEnd;
                
            if (snapHasEdge) {
                const edgeStart = currentSnapInfo.edgeStart;
                const edgeEnd = currentSnapInfo.edgeEnd;
                
                const startDist = Math.hypot(previewPoint.x - edgeStart.x, previewPoint.y - edgeStart.y) * scale;
                const endDist   = Math.hypot(previewPoint.x - edgeEnd.x,   previewPoint.y - edgeEnd.y)   * scale;
                
                // Direction unit vectors from snap point toward each endpoint
                const toStartLen = Math.hypot(edgeStart.x - previewPoint.x, edgeStart.y - previewPoint.y);
                const toEndLen   = Math.hypot(edgeEnd.x   - previewPoint.x, edgeEnd.y   - previewPoint.y);
                
                const LABEL_OFFSET = 22 / zoom; // constant screen-space offset
                const PERP_OFFSET  = 10 / zoom; // perpendicular nudge so labels don't sit on the line
                
                // Perpendicular direction (rotate edge direction 90Â°)
                const edgeDx = edgeEnd.x - edgeStart.x;
                const edgeDy = edgeEnd.y - edgeStart.y;
                const edgeLen = Math.hypot(edgeDx, edgeDy) || 1;
                const perpX = -edgeDy / edgeLen;  // unit perp
                const perpY =  edgeDx / edgeLen;
                
                ctx.save();
                ctx.font = surveyFontBold(11 / zoom);
                ctx.textAlign = 'center';
                
                // Label toward edgeStart â€” placed at offset along that direction, nudged perp
                if (toStartLen > 1 / zoom) {
                    const ux = (edgeStart.x - previewPoint.x) / toStartLen;
                    const uy = (edgeStart.y - previewPoint.y) / toStartLen;
                    const lx = previewPoint.x + ux * LABEL_OFFSET + perpX * PERP_OFFSET;
                    const ly = previewPoint.y + uy * LABEL_OFFSET + perpY * PERP_OFFSET;
                    haloText(`${convertDistance(startDist).toFixed(1)} ${getDistanceUnit()}`, lx, ly, '#0055ff');
                }
                
                // Label toward edgeEnd â€” opposite direction, nudged perp the other way
                if (toEndLen > 1 / zoom) {
                    const ux = (edgeEnd.x - previewPoint.x) / toEndLen;
                    const uy = (edgeEnd.y - previewPoint.y) / toEndLen;
                    const lx = previewPoint.x + ux * LABEL_OFFSET - perpX * PERP_OFFSET;
                    const ly = previewPoint.y + uy * LABEL_OFFSET - perpY * PERP_OFFSET;
                    haloText(`${convertDistance(endDist).toFixed(1)} ${getDistanceUnit()}`, lx, ly, '#0055ff');
                }
                
                ctx.textAlign = 'left';
                
                // Dashed guide lines from snap point to each endpoint
                ctx.strokeStyle = 'rgba(100,100,200,0.35)';
                ctx.lineWidth = 1 / zoom;
                ctx.setLineDash([2 / zoom, 3 / zoom]);
                
                ctx.beginPath();
                ctx.moveTo(previewPoint.x, previewPoint.y);
                ctx.lineTo(edgeStart.x, edgeStart.y);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(previewPoint.x, previewPoint.y);
                ctx.lineTo(edgeEnd.x, edgeEnd.y);
                ctx.stroke();
                
                ctx.restore();
            }
            
            // ENHANCED: Draw perpendicular measurement preview
            if (currentSnapInfo && currentSnapInfo.type === 'perpendicular' && mode === 'measure') {
                const firstPoint = currentSnapInfo.firstPoint;
                const edge = currentSnapInfo.edge;
                
                ctx.save();
                ctx.strokeStyle = 'hotpink';
                ctx.lineWidth = 3 / zoom;
                ctx.setLineDash([]);
                
                // Draw the perpendicular line
                ctx.beginPath();
                ctx.moveTo(firstPoint.x, firstPoint.y);
                ctx.lineTo(previewPoint.x, previewPoint.y);
                ctx.stroke();
                
                // Draw small perpendicular indicator
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2 / zoom;
                const perpSize = 8 / zoom;
                ctx.beginPath();
                ctx.moveTo(previewPoint.x - perpSize/2, previewPoint.y - perpSize/2);
                ctx.lineTo(previewPoint.x + perpSize/2, previewPoint.y - perpSize/2);
                ctx.lineTo(previewPoint.x + perpSize/2, previewPoint.y + perpSize/2);
                ctx.stroke();
                
                // Distance label
                const perpDistance = currentSnapInfo.distance * scale;
                const convertedPerpDistance = convertDistance(perpDistance);
                ctx.font = surveyFont(12 / zoom);
                ctx.textAlign = 'center';
                haloText(`âŠ¥ ${convertedPerpDistance.toFixed(1)} ${getDistanceUnit()}`,
                    (firstPoint.x + previewPoint.x) / 2 + 10 / zoom,
                    (firstPoint.y + previewPoint.y) / 2 - 10 / zoom, '#6611dd');
                
                // Show if measurement extends beyond segment
                if (!currentSnapInfo.isOnSegment) {
                    ctx.font = surveyFont(10 / zoom);
                    haloText('(extended)', previewPoint.x + 15 / zoom, previewPoint.y + 15 / zoom, '#cc6600');
                }
                
                ctx.restore();
            }
            
            // Draw preview line from last point
            {
                // In measure mode use measurePoints; in draw mode use points
                const activeArray = (mode === 'measure') ? measurePoints : points;
                if (activeArray.length > 0 && (mode === 'draw' || mode === 'measure')) {
                const lastPoint = activeArray[activeArray.length - 1];
                
                // Check for polygon closure
                if (points.length >= 3 && mode === 'draw') {
                    const snapToFirst = currentSnapInfo && currentSnapInfo.isFirstPoint;
                    if (snapToFirst) {
                        ctx.save();
                        ctx.strokeStyle = 'lime';
                        ctx.lineWidth = 4 / zoom;
                        ctx.setLineDash([8 / zoom, 8 / zoom]);
                        ctx.beginPath();
                        ctx.moveTo(lastPoint.x, lastPoint.y);
                        ctx.lineTo(points[0].x, points[0].y);
                        ctx.stroke();
                        ctx.restore();
                        return;
                    }
                }
                
                // ENHANCED: Enhanced preview line - different styles for different modes
                ctx.save();
                if (mode === 'measure') {
                    // Dark halo first for visibility on light background
                    ctx.strokeStyle = 'rgba(0,0,0,0.45)';
                    ctx.lineWidth = 5 / zoom;
                    ctx.setLineDash([8 / zoom, 6 / zoom]);
                    ctx.beginPath();
                    ctx.moveTo(lastPoint.x, lastPoint.y);
                    ctx.lineTo(previewPoint.x, previewPoint.y);
                    ctx.stroke();
                    // Purple dashed line on top
                    ctx.strokeStyle = '#6611dd';
                    ctx.lineWidth = 2.5 / zoom;
                    ctx.setLineDash([8 / zoom, 6 / zoom]);
                    ctx.globalAlpha = 1.0;
                } else {
                // Regular preview line for draw mode â€” dark halo then solid colour
                const previewHex = COLOR_MAP[currentLineColor] || '#000000';
                // Dark semi-transparent halo for contrast on light drafting-paper canvas
                ctx.strokeStyle = 'rgba(0,0,0,0.55)';
                ctx.lineWidth = 6 / zoom;
                ctx.setLineDash([6 / zoom, 5 / zoom]);
                ctx.beginPath();
                ctx.moveTo(lastPoint.x, lastPoint.y);
                ctx.lineTo(previewPoint.x, previewPoint.y);
                ctx.stroke();
                // Bright colour line on top â€” fully opaque
                ctx.strokeStyle = previewHex;
                ctx.lineWidth = 2.5 / zoom;
                }
                
                ctx.beginPath();
                ctx.moveTo(lastPoint.x, lastPoint.y);
                ctx.lineTo(previewPoint.x, previewPoint.y);
                ctx.stroke();
                ctx.restore();

                // Distance label
                let dist;
                if (mode === 'measure' && currentSnapInfo && currentSnapInfo.type === 'perpendicular') {
                    dist = currentSnapInfo.distance;
                } else {
                    dist = Math.hypot(previewPoint.x - lastPoint.x, previewPoint.y - lastPoint.y);
                }
                const displayDist = dist * scale;
                
                ctx.save();
                ctx.font = surveyFont(11 / zoom);
                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
                const convertedDisplayDist = convertDistance(displayDist);
                haloText(`${convertedDisplayDist.toFixed(1)} ${getDistanceUnit()}`,
                    previewPoint.x + 8 / zoom, previewPoint.y - 8 / zoom,
                    mode === 'measure' ? '#6611dd' : '#222222');
                ctx.restore();
                } // end activeArray.length > 0
            } // end preview line block
        }

        function drawShapes() {
            shapes.forEach(shape => {
                if (!validateShape(shape)) return;
                
                drawShape(shape);
                
                if (shape.type === 'polygon') {
                    const cache = getShapeCache(shape);
                    drawPolygonLabels(shape, cache);
                }
                
                drawEdgeMeasurements(shape);
            });
            
            // ADDITION: Draw text labels
            drawTextLabels();
        }

        // ADDITION: Draw text labels function with selection highlighting
        function buildTextFont(tl) {
            return (tl.italic?'italic ':'')+(tl.bold!==false?'bold ':'')+((tl.size||14)/zoom)+'px '+(tl.font||'Arial');
        }

        function getTextBounds(tl) {
            ctx.save(); ctx.font = buildTextFont(tl);
            const lines=(tl.text||'').split('\n'), sz=(tl.size||14)/zoom, lh=sz*1.4;
            const mw=Math.max(...lines.map(l=>ctx.measureText(l).width)); ctx.restore();
            const bx=tl.align==='center'?tl.x-mw/2:tl.align==='right'?tl.x-mw:tl.x;
            return {x:bx-4/zoom, y:tl.y-sz-2/zoom, w:mw+8/zoom, h:lines.length*lh+4/zoom};
        }

        function drawTextLabels() {
            ctx.save();
            textLabels.forEach(tl => {
                const font=buildTextFont(tl), align=tl.align||'left';
                const color=COLOR_MAP[tl.color]||tl.color||'#000000';
                const lines=(tl.text||'').split('\n'), sz=(tl.size||14)/zoom, lh=sz*1.4;
                ctx.font=font; ctx.textAlign=align;
                const mw=Math.max(...lines.map(l=>ctx.measureText(l).width));
                const bx=align==='center'?tl.x-mw/2:align==='right'?tl.x-mw:tl.x;
                if (selectedText===tl) {
                    ctx.fillStyle='rgba(255,200,0,0.25)';
                    ctx.fillRect(bx-4/zoom,tl.y-sz-2/zoom,mw+8/zoom,lines.length*lh+4/zoom);
                    ctx.strokeStyle='#ff8800'; ctx.lineWidth=2/zoom;
                    ctx.setLineDash([3/zoom,3/zoom]);
                    ctx.strokeRect(bx-4/zoom,tl.y-sz-2/zoom,mw+8/zoom,lines.length*lh+4/zoom);
                    ctx.setLineDash([]);
                }
                lines.forEach((line,i) => {
                    ctx.font=font; ctx.textAlign=align;
                    ctx.strokeStyle='rgba(255,255,255,0.7)'; ctx.lineWidth=2/zoom;
                    ctx.strokeText(line,tl.x,tl.y+i*lh);
                    ctx.fillStyle=color; ctx.fillText(line,tl.x,tl.y+i*lh);
                });
            });
            ctx.restore();
        }

        function drawShape(shape) {
            if (!validateShape(shape)) return;
            
            const shapeColor = COLOR_MAP[shape.color] || shape.color || '#000000';
            const shapeLineStyle = shape.lineStyle || 'thin';

            if (shape.type === 'measure') {
                if (shape.points.length !== 2) { return; }
                ctx.save();

                const p1 = shape.points[0];
                const p2 = shape.points[1];
                const dx = p2.x - p1.x, dy = p2.y - p1.y;
                const len = Math.hypot(dx, dy);
                if (len < 0.001) { ctx.restore(); return; }
                const ux = dx / len, uy = dy / len;   // along line
                const nx = -uy,      ny =  ux;         // perpendicular

                const lineCol = (shape.color && shape.color !== 'black') ? (COLOR_MAP[shape.color] || shape.color) : '#6611dd';
                const col = shape.labelColor ? (COLOR_MAP[shape.labelColor] || shape.labelColor) : lineCol; // use shape colour, fallback purpleure lines
                const LW  = 1.5 / zoom;
                const TICK = 6 / zoom;   // length of end-tick diagonal

                ctx.strokeStyle = lineCol;
                ctx.lineWidth   = LW;

                // â”€â”€ Main measurement line (respects lineStyle) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                const _ms = shape.lineStyle || 'thin';
                if (_ms === 'thick')       { ctx.lineWidth = 3 / zoom; ctx.setLineDash([]); }
                else if (_ms === 'medium') { ctx.lineWidth = 2 / zoom; ctx.setLineDash([]); }
                else if (_ms === 'dashed') { ctx.lineWidth = 1.5 / zoom; ctx.setLineDash([6/zoom, 4/zoom]); }
                else                       { ctx.lineWidth = 1.2 / zoom; ctx.setLineDash([]); }
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.setLineDash([]);

                // â”€â”€ Diagonal end ticks (surveyor-style serifs) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // Each tick is a short diagonal crossing the endpoint at ~45Â° to the line
                function endTick(pt) {
                    ctx.beginPath();
                    ctx.moveTo(pt.x - ux * TICK * 0.5 + nx * TICK * 0.5,
                               pt.y - uy * TICK * 0.5 + ny * TICK * 0.5);
                    ctx.lineTo(pt.x + ux * TICK * 0.5 - nx * TICK * 0.5,
                               pt.y + uy * TICK * 0.5 - ny * TICK * 0.5);
                    ctx.stroke();
                }
                endTick(p1);
                endTick(p2);

                // â”€â”€ Label above midpoint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                const dist = shape.distance || len * scale;
                const convertedDist = convertDistance(dist);
                const label = shape.measureType === 'perpendicular'
                    ? `âŠ¥ ${convertedDist.toFixed(2)} ${getDistanceUnit()}`
                    : `${convertedDist.toFixed(2)} ${getDistanceUnit()}`;

                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;

                // Use custom-dragged position if available, else default perpendicular offset
                const _customLabelPos = distancePositions.get(shape);
                const labelX = _customLabelPos ? _customLabelPos.x : midX + nx * 8 / zoom;
                const labelY = _customLabelPos ? _customLabelPos.y : midY + ny * 8 / zoom;

                ctx.font = surveyFontBold(11 / zoom);
                ctx.textAlign   = 'center';
                ctx.textBaseline = 'bottom';
                haloText(label, labelX, labelY, col);

                // â”€â”€ Selected highlight â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if (selectedMeasurement === shape) {
                    ctx.save();
                    ctx.strokeStyle = '#ff8800';
                    ctx.lineWidth   = 3 / zoom;
                    ctx.globalAlpha = 0.8;
                    ctx.setLineDash([5 / zoom, 3 / zoom]);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                    ctx.restore();
                }

                ctx.restore();
                return;
            }

            // For polygons: fill first, then stroke outline as a separate pass so
            // drawPolygonWithPattern's internal ctx.beginPath() can't destroy our path.
            if (shape.type === 'polygon') {
                drawPolygonWithPattern(shape);  // handles fill (has its own save/restore)

                // Now stroke the outline on a fresh path
                ctx.beginPath();
                ctx.strokeStyle = shapeColor;
                switch(shapeLineStyle) {
                    case 'thick':  ctx.lineWidth = 4 / zoom; ctx.setLineDash([]); break;
                    case 'medium': ctx.lineWidth = 2.5 / zoom; ctx.setLineDash([]); break;
                    case 'dashed': ctx.lineWidth = 2 / zoom; ctx.setLineDash([8/zoom, 6/zoom]); break;
                    default:       ctx.lineWidth = 1.2 / zoom; ctx.setLineDash([]);
                }
                shape.points.forEach((p, i) => { if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
                return;
            }

            // Lines and everything else
            ctx.beginPath();
            ctx.strokeStyle = shapeColor;
            switch(shapeLineStyle) {
                case 'thick':  ctx.lineWidth = 4 / zoom; ctx.setLineDash([]); break;
                case 'medium': ctx.lineWidth = 2.5 / zoom; ctx.setLineDash([]); break;
                case 'dashed': ctx.lineWidth = 2 / zoom; ctx.setLineDash([8/zoom, 6/zoom]); break;
                default:       ctx.lineWidth = 1.2 / zoom; ctx.setLineDash([]);
            }
            shape.points.forEach((p, i) => { if (i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Cache for hatch patterns keyed by color name
        const hatchPatternCache = new Map(); // colorName â†’ canvas element
        const HATCH_PX = 12; // fixed screen-pixel spacing between hatch lines

        // Returns a pattern that always appears HATCH_PX pixels on screen,
        // regardless of zoom, by using pattern.setTransform to undo the world scale.
        function getHatchPattern(colorName, color) {
            // Reuse the same tiny canvas per color; create if missing
            let pc = hatchPatternCache.get(colorName);
            if (!pc) {
                pc = document.createElement('canvas');
                pc.width  = HATCH_PX;
                pc.height = HATCH_PX;
                const px = pc.getContext('2d');
                px.strokeStyle = color;
                px.lineWidth   = 0.8;
                px.lineCap     = 'butt';
                px.beginPath();
                px.moveTo(0, 0);        px.lineTo(HATCH_PX, HATCH_PX);
                px.moveTo(HATCH_PX, 0); px.lineTo(0, HATCH_PX);
                px.stroke();
                hatchPatternCache.set(colorName, pc);
            }
            // Create pattern from the fixed-pixel canvas
            const pat = ctx.createPattern(pc, 'repeat');
            // Counteract the ctx.scale(zoom,zoom) so the tile is always HATCH_PX screen-px
            pat.setTransform(new DOMMatrix().scale(1 / zoom, 1 / zoom));
            return pat;
        }

        // Draw polygon fill â€” solid or hatch â€” respecting per-shape fillOpacity
        function drawPolygonWithPattern(shape) {
            if (!shape.fill || shape.fill === 'none') return;

            const alpha = (shape.fillOpacity != null) ? shape.fillOpacity : polygonFillOpacity;

            ctx.save();
            ctx.globalAlpha = Math.max(0, Math.min(1, alpha));

            // Clipping path
            ctx.beginPath();
            shape.points.forEach((point, i) => {
                if (i === 0) ctx.moveTo(point.x, point.y);
                else ctx.lineTo(point.x, point.y);
            });
            ctx.closePath();
            ctx.clip();

            if (shape.fill.startsWith('solid-')) {
                const colorName = shape.fill.replace('solid-', '');
                const color = COLOR_MAP[colorName] || colorName;
                ctx.fillStyle = color;
                ctx.fill();
            } else if (shape.fill.startsWith('hatch-')) {
                const colorName = shape.fill.replace('hatch-', '');
                const color = COLOR_MAP[colorName] || colorName;
                ctx.fillStyle = getHatchPattern(colorName, color);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawPolygonLabels(shape, cache) {
            const totalArea = calculateTotalArea(shape);
            
            const labelPosition = labelPositions.get(shape) || findBestLabelPosition(shape, cache.centroid);
            const ls = LAYER_STYLES[shape.layer || 'boundary'];
            const isFeature = (shape.layer || 'boundary') === 'feature';
            
            // Default sub-label: editable via Edit Text
            const subLabel = (shape.areaSubLabel !== undefined)
                ? shape.areaSubLabel
                : (isFeature ? 'Feature' : 'Lot Area');
            
            ctx.save();
            
            if (selectedLabel && selectedLabel.shape === shape) {
                ctx.fillStyle = 'yellow';
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.arc(labelPosition.x, labelPosition.y, 34 / zoom, 0, 2 * Math.PI);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.strokeStyle = 'orange';
                ctx.lineWidth = 2 / zoom;
                ctx.setLineDash([3 / zoom, 3 / zoom]);
                ctx.beginPath();
                ctx.arc(labelPosition.x, labelPosition.y, 34 / zoom, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            ctx.textAlign = 'center';
            
            // Area number â€” use areaLabelColor override if set, else layer default
            ctx.font = surveyFontBold(ls.areaSize / zoom);
            const _areaLabelDefault = (shape.layer === 'boundary')
                ? ls.areaColor
                : (COLOR_MAP[shape.color] || shape.color || ls.areaColor);
            const _areaLabelCol = shape.areaLabelColor
                ? (COLOR_MAP[shape.areaLabelColor] || shape.areaLabelColor)
                : _areaLabelDefault;
            haloText(`${Math.round(convertArea(totalArea))} ${getAreaUnit()}`, labelPosition.x, labelPosition.y, _areaLabelCol);
            
            // Sub-label (e.g. "Lot Area" / "Feature" / custom text)
            if (subLabel) {
                ctx.font = surveyFontBold(8 / zoom);
                haloText(subLabel.toUpperCase(), labelPosition.x, labelPosition.y + 12 / zoom, _areaLabelCol);
            }
            
            ctx.textAlign = 'left';
            ctx.restore();
        }

        function drawEdgeMeasurements(shape) {
            // Measure shapes: line + label are fully rendered in drawShape(); nothing to do here.
            if (shape.type === 'measure') return;
            
            const edgeCount = shape.type === 'polygon' ? shape.points.length - 1 : shape.points.length - 1;
            const ls = LAYER_STYLES[shape.layer || 'boundary'];
            
            for (let i = 0; i < edgeCount; i++) {
                const p1 = shape.points[i];
                const p2 = shape.points[i + 1];
                
                if (Math.hypot(p2.x - p1.x, p2.y - p1.y) < 1) continue;
                
                const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y) * scale;
                const convertedDist = convertDistance(dist);
                
                const defaultX = (p1.x + p2.x) / 2;
                const defaultY = (p1.y + p2.y) / 2 - 8 / zoom;
                
                const edgeKey = `${ensureShapeId(shape)}_edge_${i}`;
                
                // Skip if this label has been hidden via Edit Text
                // (hidden labels not supported â€” all labels shown)
                
                const labelPos = distancePositions.get(edgeKey) || { x: defaultX, y: defaultY };
                
                // Highlight if selected
                if (selectedDistance && selectedDistance.key === edgeKey) {
                    ctx.save();
                    ctx.fillStyle = 'yellow';
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(labelPos.x - 20 / zoom, labelPos.y - 8 / zoom, 40 / zoom, 12 / zoom);
                    ctx.globalAlpha = 1;
                    ctx.strokeStyle = 'orange';
                    ctx.lineWidth = 2 / zoom;
                    ctx.setLineDash([3 / zoom, 3 / zoom]);
                    ctx.strokeRect(labelPos.x - 20 / zoom, labelPos.y - 8 / zoom, 40 / zoom, 12 / zoom);
                    ctx.setLineDash([]);
                    ctx.restore();
                }
                
                ctx.font = (ls.edgeBold !== false ? surveyFontBold : surveyFont)(ls.edgeSize / zoom);
                ctx.textAlign = 'center';
                // Feature labels match line colour; boundary keeps layer default (blue)
                const _edgeLabelColor = (shape.layer === 'boundary')
                    ? ls.edgeColor
                    : (COLOR_MAP[shape.color] || shape.color || ls.edgeColor);
                haloText(`${convertedDist.toFixed(1)} ${getDistanceUnit()}`, labelPos.x, labelPos.y, _edgeLabelColor);
                ctx.textAlign = 'left';
            }
        }

        function drawCurrentPoints() {
            // Draw mode: in-progress polyline
            if (points.length > 0) {
                const inProgHex = COLOR_MAP[currentLineColor] || currentLineColor;
                let inProgWidth;
                switch(currentLineStyle) {
                    case 'thick':  inProgWidth = 4; break;
                    case 'medium': inProgWidth = 2.5; break;
                    case 'dashed': inProgWidth = 2; break;
                    default:       inProgWidth = 1.8;
                }
                const inProgDash = currentLineStyle === 'dashed' ? [5/zoom, 5/zoom] : [];
                
                // Dark halo pass for contrast on light background
                ctx.save();
                ctx.strokeStyle = 'rgba(0,0,0,0.4)';
                ctx.lineWidth = (inProgWidth + 3) / zoom;
                ctx.setLineDash(inProgDash);
                ctx.beginPath();
                points.forEach((p, i) => { if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); });
                ctx.stroke();
                // Solid colour on top
                ctx.strokeStyle = inProgHex;
                ctx.lineWidth = inProgWidth / zoom;
                ctx.beginPath();
                points.forEach((p, i) => { if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); });
                ctx.stroke();
                ctx.setLineDash([]);
                // Vertex dots with halo
                points.forEach(p => {
                    ctx.fillStyle = 'rgba(0,0,0,0.35)';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 6/zoom, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.fillStyle = inProgHex;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4/zoom, 0, 2*Math.PI);
                    ctx.fill();
                });
                ctx.restore();
            }

            // Measure mode: show placed first point while waiting for second
            if (mode === 'measure' && measurePoints.length === 1) {
                const p = measurePoints[0];
                ctx.save();
                ctx.fillStyle = '#6611dd';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1.5 / zoom;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5/zoom, 0, 2*Math.PI);
                ctx.fill();
                ctx.stroke();
                // Small crosshair
                ctx.strokeStyle = '#6611dd';
                ctx.lineWidth = 1 / zoom;
                const c = 8 / zoom;
                ctx.beginPath();
                ctx.moveTo(p.x - c, p.y); ctx.lineTo(p.x + c, p.y);
                ctx.moveTo(p.x, p.y - c); ctx.lineTo(p.x, p.y + c);
                ctx.stroke();
                ctx.restore();
            }
        }

        function drawSelectionHighlights() {
            // â”€â”€ Multi-select highlights (all shapes in selectedShapes) â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (selectedShapes.size > 0) {
                selectedShapes.forEach(shape => {
                    ctx.save();
                    ctx.strokeStyle = '#ff8800';
                    ctx.lineWidth = 5 / zoom;
                    ctx.setLineDash([8 / zoom, 4 / zoom]);
                    ctx.globalAlpha = 0.9;
                    ctx.beginPath();
                    if (shape.type === 'polygon') {
                        shape.points.forEach((p, i) => { if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); });
                        ctx.closePath();
                    } else if (shape.type === 'line' || shape.type === 'measure') {
                        shape.points.forEach((p, i) => { if (i === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); });
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                });
            }
            if (selectedPoint) {
                ctx.beginPath();
                ctx.arc(selectedPoint.x, selectedPoint.y, 8 / zoom, 0, 2 * Math.PI);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 3 / zoom;
                ctx.stroke();
            }
            
            if (selectedEdge) {
                ctx.beginPath();
                ctx.moveTo(selectedEdge.startPoint.x, selectedEdge.startPoint.y);
                ctx.lineTo(selectedEdge.endPoint.x, selectedEdge.endPoint.y);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 4 / zoom;
                ctx.stroke();
            }
            
            if (selectedPolygonForFill) {
                ctx.beginPath();
                selectedPolygonForFill.points.forEach((point, i) => {
                    if (i === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                });
                ctx.closePath();
                ctx.strokeStyle = 'lime';
                ctx.lineWidth = 3 / zoom;
                ctx.stroke();
            }
            
            // Highlight selected measurement line (only if not already highlighted via selectedShapes)
            if (selectedMeasurement && !selectedShapes.has(selectedMeasurement)) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(selectedMeasurement.points[0].x, selectedMeasurement.points[0].y);
                ctx.lineTo(selectedMeasurement.points[1].x, selectedMeasurement.points[1].y);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 6 / zoom;
                ctx.globalAlpha = 0.7;
                ctx.stroke();
                
                // Add selection indicators at endpoints
                ctx.globalAlpha = 1;
                ctx.fillStyle = 'red';
                selectedMeasurement.points.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 6 / zoom, 0, 2 * Math.PI);
                    ctx.fill();
                });
                ctx.restore();
            }
            
            // ADDITION: Show distance move mode indicator
            if (distanceMoveMode && selectedDistance && previewPoint) {
                ctx.save();
                ctx.strokeStyle = 'purple';
                ctx.lineWidth = 2 / zoom;
                ctx.setLineDash([5 / zoom, 5 / zoom]);
                ctx.beginPath();
                ctx.moveTo(selectedDistance.position.x, selectedDistance.position.y);
                ctx.lineTo(previewPoint.x, previewPoint.y);
                ctx.stroke();
                
                // Ghost distance label at preview position
                ctx.globalAlpha = 0.6;
                ctx.font = surveyFont(11 / zoom);
                ctx.textAlign = 'center';
                
                // Calculate distance text to show in preview
                let previewText = '';
                if (selectedDistance.edgeIndex !== undefined) {
                    const shape = selectedDistance.shape;
                    const i = selectedDistance.edgeIndex;
                    const p1 = shape.points[i];
                    const p2 = shape.points[i + 1];
                    const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y) * scale;
                    const convertedDist = convertDistance(dist);
                    previewText = `${convertedDist.toFixed(1)} ${getDistanceUnit()}`;
                } else {
                    const shape = selectedDistance.shape;
                    if (shape.type === 'measure' && shape.points.length === 2) {
                        const dist = shape.distance || Math.hypot(
                            shape.points[1].x - shape.points[0].x,
                            shape.points[1].y - shape.points[0].y
                        ) * scale;
                        const convertedDist = convertDistance(dist);
                        previewText = shape.measureType === 'perpendicular' ? `âŠ¥ ${convertedDist.toFixed(2)} ${getDistanceUnit()}` : `${convertedDist.toFixed(2)} ${getDistanceUnit()}`;
                    }
                }
                
                haloText(previewText, previewPoint.x, previewPoint.y, '#6611dd');
                ctx.globalAlpha = 1;
                ctx.textAlign = 'left';
                ctx.restore();
            }
            
            // ADDITION: Show text move mode indicator
            if (textMoveMode && selectedText && previewPoint) {
                ctx.save();
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2 / zoom;
                ctx.setLineDash([5 / zoom, 5 / zoom]);
                ctx.beginPath();
                ctx.moveTo(selectedText.x, selectedText.y);
                ctx.lineTo(previewPoint.x, previewPoint.y);
                ctx.stroke();
                
                // Ghost text at preview position
                ctx.globalAlpha = 0.6;
                ctx.font = surveyFont(14 / zoom);
                ctx.textAlign = 'left';
                haloText(selectedText.text, previewPoint.x, previewPoint.y, '#0055ff');
                ctx.globalAlpha = 1;
                ctx.restore();
            }
            
            // ADDITION: Show label move mode indicator
            if (labelMoveMode && selectedLabel && previewPoint) {
                ctx.save();
                ctx.strokeStyle = 'orange';
                ctx.lineWidth = 2 / zoom;
                ctx.setLineDash([5 / zoom, 5 / zoom]);
                ctx.beginPath();
                ctx.moveTo(selectedLabel.position.x, selectedLabel.position.y);
                ctx.lineTo(previewPoint.x, previewPoint.y);
                ctx.stroke();
                
                // Ghost label at preview position
                ctx.globalAlpha = 0.6;
                ctx.textAlign = 'center';
                const totalArea = calculateTotalArea(selectedLabel.shape);
                const ls2 = LAYER_STYLES[selectedLabel.shape.layer || 'boundary'];
                const isF = (selectedLabel.shape.layer || 'boundary') === 'feature';
                const sub = selectedLabel.shape.areaSubLabel !== undefined
                    ? selectedLabel.shape.areaSubLabel
                    : (isF ? 'Feature' : 'Lot Area');
                ctx.font = surveyFont(ls2.areaSize / zoom);
                const _prevDefault = isF ? (COLOR_MAP[selectedLabel.shape.color] || selectedLabel.shape.color || ls2.areaColor) : ls2.areaColor;
                const _prevCol = selectedLabel.shape.areaLabelColor ? (COLOR_MAP[selectedLabel.shape.areaLabelColor] || selectedLabel.shape.areaLabelColor) : _prevDefault;
                haloText(`${Math.round(convertArea(totalArea))} ${getAreaUnit()}`, previewPoint.x, previewPoint.y, _prevCol);
                if (sub) {
                    ctx.font = surveyFont(8 / zoom);
                    haloText(sub.toUpperCase(), previewPoint.x, previewPoint.y + 12 / zoom, _prevCol);
                }
                ctx.globalAlpha = 1;
                ctx.textAlign = 'left';
                ctx.restore();
            }
            
            if (bisectionTarget) {
                const poly = bisectionTarget.polygon;
                ctx.beginPath();
                poly.points.forEach((point, i) => {
                    if (i === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                });
                ctx.closePath();
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 4 / zoom;
                ctx.stroke();
            }
        }

        function requestRedraw() {
            if (redrawTimeout) return;
            redrawTimeout = requestAnimationFrame(() => {
                redrawCanvas();
                redrawTimeout = null;
            });
            scheduleAutosave();
        }

        function redrawCanvas() {
            validateViewport();
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#f9f9f9';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoom, zoom);

            if (backgroundImage && showImage) {
                ctx.save();
                ctx.globalAlpha = imageOpacity;
                
                ctx.translate(imageTransform.x, imageTransform.y);
                ctx.scale(imageTransform.scale, imageTransform.scale);
                ctx.rotate(imageTransform.rotation * Math.PI / 180);
                
                const imgWidth = backgroundImage.width;
                const imgHeight = backgroundImage.height;
                ctx.drawImage(backgroundImage, -imgWidth/2, -imgHeight/2, imgWidth, imgHeight);
                
                ctx.restore();
            }

            drawShapes();
            drawCurrentPoints();
            drawPreviewElements();
            drawSelectionHighlights();
            
            // â”€â”€ Debug overlay: show selection count top-left â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if (selectedShapes.size > 0 || selectedShape) {
                ctx.save();
                ctx.setTransform(1,0,0,1,0,0); // reset to screen coords
                ctx.fillStyle = 'rgba(0,0,0,0.65)';
                ctx.fillRect(4, 4, 240, 20);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 11px monospace';
                ctx.textBaseline = 'top';
                const names = [...selectedShapes].map(s => s.type + (s.lineStyle ? ':'+s.lineStyle : '')).join(', ');
                ctx.fillText(`SEL: ${selectedShapes.size} [${names}]  shape=${!!selectedShape}`, 8, 6);
                ctx.restore();
            }

            ctx.restore();
        }

        function exportSVG() {
            // Helper to convert fill pattern name to SVG-compatible fill + opacity
            function svgFill(fill) {
                if (!fill || fill === 'none') return { fill: 'none', opacity: 1 };
                if (fill.startsWith('solid-')) {
                    const colorName = fill.replace('solid-', '');
                    return { fill: COLOR_MAP[colorName] || '#000000', opacity: 0.25 };
                }
                if (fill.startsWith('hatch-')) {
                    const colorName = fill.replace('hatch-', '');
                    return { fill: COLOR_MAP[colorName] || '#000000', opacity: 0.4, hatch: true };
                }
                return { fill: 'none', opacity: 1 };
            }
            
            const w = canvas.width;
            const h = canvas.height;
            
            // Build hatch pattern defs for any hatch fills in use
            const hatchColors = new Set();
            shapes.forEach(s => { if (s.fill && s.fill.startsWith('hatch-')) hatchColors.add(s.fill.replace('hatch-', '')); });
            
            let defs = '';
            if (hatchColors.size > 0) {
                defs = '<defs>';
                hatchColors.forEach(colorName => {
                    const color = COLOR_MAP[colorName] || '#000000';
                    defs += `<pattern id="hatch-${colorName}" patternUnits="userSpaceOnUse" width="24" height="24">` +
                        `<line x1="0" y1="0" x2="24" y2="24" stroke="${color}" stroke-width="1"/>` +
                        `<line x1="0" y1="24" x2="24" y2="0" stroke="${color}" stroke-width="1"/>` +
                        `</pattern>`;
                });
                defs += '</defs>';
            }
            
            let svg = `<svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">${defs}`;
            svg += `<g transform="translate(${offsetX},${offsetY}) scale(${zoom})">`;
            
            shapes.forEach(shape => {
                if (!validateShape(shape)) return;
                const pts = shape.points.map(p => `${p.x},${p.y}`).join(' ');
                const stroke = COLOR_MAP[shape.color] || shape.color || '#000000';
                const lw = shape.lineStyle === 'thick' ? 4/zoom : 2/zoom;
                const dash = shape.lineStyle === 'dashed' ? `stroke-dasharray="${5/zoom},${5/zoom}"` : '';
                
                if (shape.type === 'polygon') {
                    const { fill, opacity, hatch } = svgFill(shape.fill);
                    const svgFillAttr = hatch ? `url(#hatch-${shape.fill.replace('hatch-', '')})` : fill;
                    svg += `<polygon points="${pts}" fill="${svgFillAttr}" fill-opacity="${opacity}" stroke="${stroke}" stroke-width="${lw}" ${dash}/>`;
                    // Area label
                    const cache = getShapeCache(shape);
                    const pos = labelPositions.get(shape) || findBestLabelPosition(shape, cache.centroid);
                    const area = Math.round(convertArea(calculateTotalArea(shape)));
                    svg += `<text x="${pos.x}" y="${pos.y}" text-anchor="middle" fill="red" font-size="${16/zoom}" font-family="Courier New, Lucida Console, monospace">${area} ${getAreaUnit()}</text>`;
                } else if (shape.type === 'line') {
                    svg += `<polyline points="${pts}" fill="none" stroke="${stroke}" stroke-width="${lw}" ${dash}/>`;
                } else if (shape.type === 'measure') {
                    svg += `<line x1="${shape.points[0].x}" y1="${shape.points[0].y}" x2="${shape.points[1].x}" y2="${shape.points[1].y}" stroke="purple" stroke-width="${1/zoom}"/>`;
                    const mx = (shape.points[0].x + shape.points[1].x) / 2;
                    const my = (shape.points[0].y + shape.points[1].y) / 2 - 8/zoom;
                    const dist = convertDistance(shape.distance || 0).toFixed(2);
                    svg += `<text x="${mx}" y="${my}" text-anchor="middle" fill="purple" font-size="${11/zoom}" font-family="Courier New, Lucida Console, monospace">${dist} ${getDistanceUnit()}</text>`;
                }
            });
            
            // Text labels
            textLabels.forEach(t => {
                const color = COLOR_MAP[t.color] || t.color || '#000000';
                svg += `<text x="${t.x}" y="${t.y}" fill="${color}" font-size="${14/zoom}" font-family="Courier New, Lucida Console, monospace">${t.text}</text>`;
            });
            
            svg += '</g></svg>';
            
            const dataUri = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
            const a = document.createElement('a');
            a.href = dataUri;
            a.download = 'lot_layout.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        const MODE_HINTS = {
            draw:      'âœï¸ <kbd>Click</kbd> add point Â· <kbd>Esc</kbd> finish line Â· snap to start to close polygon Â· <kbd>Del</kbd> undo last point',
            select:    'â†– <kbd>Click</kbd> line/shape to select Â· <kbd>Ctrl+Click</kbd> multi-select Â· then change Color/Style Â· <kbd>Del</kbd> delete Â· <kbd>Esc</kbd> deselect',
            measure:   'ğŸ“ <kbd>Click</kbd> point 1 Â· <kbd>Click</kbd> point 2 Â· <kbd>Esc</kbd> cancel',
            text:      'T <kbd>Click</kbd> canvas to place text Â· <kbd>Esc</kbd> exit',
            editText:  'âœ <kbd>Click</kbd> area label (edit sub-text) Â· text label (edit/delete) Â· dimension number (hide/show) Â· <kbd>Esc</kbd> exit',
            paint:     'ğŸ¨ <kbd>Click</kbd> inside a polygon to fill Â· <kbd>Esc</kbd> exit',
            moveImage: 'ğŸ–¼ <kbd>Click+drag</kbd> to reposition image Â· <kbd>â†‘â†“â†â†’</kbd> nudge Â· <kbd>Shift+â†‘â†“â†â†’</kbd> coarse Â· drag corners to scale Â· <kbd>Esc</kbd> exit',
            pan: 'âœ‹ <kbd>Drag</kbd> to pan Â· <kbd>Scroll</kbd> to zoom Â· <kbd>H</kbd> to exit'
        };
        const MODE_CURSORS = {
            draw: 'crosshair', select: 'default', measure: 'crosshair',
            text: 'text', editText: 'text', paint: 'cell', moveImage: 'move', pan: 'grab'
        };

        function updateModeButtons() {
            document.querySelectorAll('#toolbar .tool-btn, #toolbar button').forEach(btn => btn.classList.remove('active-mode'));
            const btnMap = {
                draw:'drawBtn', select:'selectBtn', measure:'measureBtn',
                text:'textBtn', editText:'editTextBtn', paint:'paintBtn', moveImage:'moveImageBtn', pan:'panBtn'
            };
            if (btnMap[mode]) document.getElementById(btnMap[mode]).classList.add('active-mode');

            // Cursor
            if (!spaceHeld) canvas.style.cursor = MODE_CURSORS[mode] || 'default';

            // Context hint
            const hint = document.getElementById('contextHint');
            hint.innerHTML = MODE_HINTS[mode] || '';

            // Point counter for draw mode
            updateDrawCounter();
        }

        function updateDrawCounter() {
            const hint = document.getElementById('contextHint');
            if (mode === 'draw' && points.length > 0) {
                hint.innerHTML = `âœï¸ ${points.length} point${points.length>1?'s':''} Â· <kbd>Esc</kbd> finish Â· <kbd>Del</kbd> undo last Â· snap to â— to close`;
            } else if (mode === 'measure' && measurePoints.length === 1) {
                hint.innerHTML = `ğŸ“ Point 1 placed â€” click for point 2 Â· <kbd>Esc</kbd> cancel`;
            }
        }

        // Event listeners
        document.getElementById('measureBtn').addEventListener('click', () => {
            exitImageMode();
            mode = 'measure';
            resetDrawingState();
            measurePoints = [];
            selectedShape = null;
            selectedPoint = null;
            selectedEdge = null;
            selectedPolygonForFill = null;
            selectedLabel = null;
            labelMoveMode = false;
            selectedText = null;
            textMoveMode = false;
            selectedDistance = null;
            distanceMoveMode = false;
            selectedMeasurement = null;
            dragStart = null;
            document.getElementById('fillPatterns').style.display = 'none';
            updateModeButtons();
            requestRedraw();
        });

        // ENHANCED: New perpendicular snap toggle button
        document.getElementById('perpSnapBtn').addEventListener('click', () => {
            enablePerpSnap = !enablePerpSnap;
            document.getElementById('perpSnapBtn').textContent = `Perp Snap: ${enablePerpSnap ? 'ON' : 'OFF'}`;
            debug(`Perpendicular snap: ${enablePerpSnap ? 'enabled' : 'disabled'}`);
        });

        function updateLayerBtn() {
            const isBoundary = currentLayer === 'boundary';
            const hint = document.getElementById('layerHint');
            const bBtn = document.getElementById('boundaryLayerBtn');
            const fBtn = document.getElementById('featureLayerBtn');
            if (bBtn) { bBtn.classList.toggle('layer-active', isBoundary); }
            if (fBtn) { fBtn.classList.toggle('layer-active', !isBoundary); }
            hint.textContent = isBoundary
                ? 'Lot boundary â€” sets total lot area'
                : 'Feature â€” buildings, driveways etc. (own dimensions)';
        }

        document.getElementById('boundaryLayerBtn').addEventListener('click', () => {
            currentLayer = 'boundary'; updateLayerBtn();
            showStatus('Layer: Lot Boundary');
        });
        document.getElementById('featureLayerBtn').addEventListener('click', () => {
            currentLayer = 'feature'; updateLayerBtn();
            showStatus('Layer: Feature');
        });
        // Keep legacy layerBtn click for compatibility
        document.getElementById('layerBtn').addEventListener('click', () => {
            currentLayer = currentLayer === 'boundary' ? 'feature' : 'boundary';
            updateLayerBtn();
        });

        // ENHANCED: Zoom to fit button
        document.getElementById('zoomToFitBtn').addEventListener('click', () => {
            zoomToFit();
        });

        document.getElementById('unitsBtn').addEventListener('click', () => {
            useMetricUnits = !useMetricUnits;
            updateUnitLabels();
            shapeCache.clear(); // Clear cache to update area labels
            requestRedraw();
            debug(`Units switched to: ${useMetricUnits ? 'Metric' : 'Imperial'}`);
        });

        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);

        document.getElementById('clearBtn').addEventListener('click', () => {
            if (!confirm('Clear all shapes, measurements and text? This cannot be undone.')) return;
            saveHistoryState();
            shapes = [];
            resetDrawingState();
            measurePoints = [];
            selectedShape = null; selectedPoint = null; selectedEdge = null;
            selectedPolygonForFill = null; dragStart = null;
            labelPositions.clear(); selectedLabel = null; labelMoveMode = false;
            selectedText = null; textMoveMode = false;
            selectedDistance = null; distanceMoveMode = false;
            selectedMeasurement = null;
            textLabels = []; distancePositions.clear(); shapeCache.clear();
            showStatus('Canvas cleared');
            requestRedraw();
        });

        document.getElementById('exportBtn').addEventListener('click', exportSVG);

        document.getElementById('exportPngBtn').addEventListener('click', exportPNG);

        function exportPNG() {
            if (shapes.length === 0 && textLabels.length === 0) {
                showStatus('Nothing to export'); return;
            }
            // Save current view
            const savedZoom = zoom, savedOffX = offsetX, savedOffY = offsetY;

            // Fit all content into view
            zoomToFit();

            // Temporarily suppress the debug selection overlay during export
            const _savedSelectedShapes = selectedShapes;
            const _savedSelectedShape  = selectedShape;
            selectedShapes = new Set(); selectedShape = null;

            // Draw a clean frame (includes background image, fills, hatches, labels)
            redrawCanvas();

            // Stamp disclaimer onto the bottom-right corner
            (function stampDisclaimer() {
                const txt = 'This design tool makes no warranty for accuracy. Not a legal survey.';
                ctx.save();
                ctx.font = 'italic 10px Arial';
                const tw = ctx.measureText(txt).width;
                const bx = canvas.width - tw - 14, by = canvas.height - 16;
                ctx.fillStyle = 'rgba(255,255,255,0.80)';
                ctx.fillRect(bx - 3, by - 2, tw + 6, 15);
                ctx.fillStyle = '#8a3a3a';
                ctx.textBaseline = 'top';
                ctx.fillText(txt, bx, by);
                ctx.restore();
            })();

            // Snapshot the canvas
            canvas.toBlob(blob => {
                // Restore view and selection state
                zoom = savedZoom; offsetX = savedOffX; offsetY = savedOffY;
                selectedShapes = _savedSelectedShapes; selectedShape = _savedSelectedShape;
                redrawCanvas();

                if (!blob) { showStatus('Export failed'); return; }
                const url = URL.createObjectURL(blob);
                const a   = document.createElement('a');
                const now = new Date();
                a.href     = url;
                a.download = 'lot-' + now.getFullYear() + '-'
                    + String(now.getMonth()+1).padStart(2,'0') + '-'
                    + String(now.getDate()).padStart(2,'0') + '.png';
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                setTimeout(() => URL.revokeObjectURL(url), 1000);
                showStatus('PNG exported (' + canvas.width + 'x' + canvas.height + 'px)');
            }, 'image/png');
        }

        document.getElementById('scale').addEventListener('change', () => {
            scale = parseFloat(document.getElementById('scale').value) || 1;
            shapeCache.clear();
            requestRedraw();
        });

        document.getElementById('toggleSnaps').addEventListener('click', () => {
            enable90DegSnaps = !enable90DegSnaps;
            document.getElementById('toggleSnaps').textContent = `90Â° Snaps: ${enable90DegSnaps ? 'ON' : 'OFF'}`;
            debug(`90-degree snaps: ${enable90DegSnaps ? 'enabled' : 'disabled'}`);
        });

        document.getElementById('imageUpload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    backgroundImage = new Image();
                    backgroundImage.onload = () => {
                        showImage = true;
                        // Reset imageTransform so image is centred in world-space at origin
                        imageTransform = { x: 0, y: 0, scale: 1, rotation: 0 };
                        // Fit the image to the canvas with padding
                        const padding = 60;
                        const imgW = backgroundImage.width;
                        const imgH = backgroundImage.height;
                        const scaleX = (canvas.width  - 2 * padding) / imgW;
                        const scaleY = (canvas.height - 2 * padding) / imgH;
                        zoom = Math.min(scaleX, scaleY, 4);
                        // Image is drawn centred at imageTransform (0,0) in world coords
                        offsetX = canvas.width  / 2;
                        offsetY = canvas.height / 2;
                        showStatus('Image loaded â€” use Move Image to reposition');
                        // Update drop zone in sidebar
                        const _dz = document.getElementById('imgDropZone');
                        if (_dz) { _dz.classList.add('has-image'); _dz.innerHTML = '<span class="drop-ico">âœ…</span>Image loaded<br><span style="font-size:9px;color:#4a9a4a;">Click to replace</span>'; }
                        const _ic = document.getElementById('imageControls');
                        if (_ic) _ic.classList.add('visible');
                        // Update toggle button text
                        const _tb = document.getElementById('bbToggleImage');
                        if (_tb) _tb.textContent = 'ğŸ‘ Hide Bg';
                        requestRedraw();
                    };
                    backgroundImage.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('toggleImage').addEventListener('click', () => {
            showImage = !showImage;
            const btn = document.getElementById('bbToggleImage');
            if (btn) btn.textContent = showImage ? 'ğŸ‘ Hide Bg' : 'ğŸ‘ Show Bg';
            requestRedraw();
        });

        document.getElementById('transparency').addEventListener('input', (e) => {
            imageOpacity = parseFloat(e.target.value);
            requestRedraw();
        });

        document.getElementById('imageRotation').addEventListener('input', (e) => {
            imageTransform.rotation = parseFloat(e.target.value) || 0;
            requestRedraw();
        });

        document.getElementById('drawBtn').addEventListener('click', () => {
            exitImageMode();
            mode = 'draw';
            resetDrawingState();
            selectedShape = null;
            selectedPoint = null;
            selectedEdge = null;
            selectedPolygonForFill = null;
            selectedLabel = null;
            labelMoveMode = false;
            selectedText = null;
            textMoveMode = false;
            selectedDistance = null;
            distanceMoveMode = false;
            selectedMeasurement = null;
            dragStart = null;
            document.getElementById('fillPatterns').style.display = 'none';
            document.getElementById('imageRotationControl').classList.add('hidden');
            updateModeButtons();
            requestRedraw();
        });

        document.getElementById('selectBtn').addEventListener('click', () => {
            exitImageMode();
            mode = 'select';
            resetDrawingState();
            selectedShape = null;
            selectedPoint = null;
            selectedEdge = null;
            // ADDITION: Don't clear selectedLabel and labelMoveMode here - select mode handles labels
            // ADDITION: Don't clear selectedText and textMoveMode here - select mode handles text labels
            // ADDITION: Don't clear selectedDistance and distanceMoveMode here - select mode handles distance labels
            // ADDITION: Don't clear selectedMeasurement here - select mode handles measurement selection
            dragStart = null;
            document.getElementById('fillPatterns').style.display = 'none';
            document.getElementById('imageRotationControl').classList.add('hidden');
            updateModeButtons();
            requestRedraw();
        });

        document.getElementById('panBtn').addEventListener('click', () => {
            exitImageMode();
            mode = 'pan';
            resetDrawingState();
            updateModeButtons();
        });

        // ADDITION: Text mode button
        document.getElementById('textBtn').addEventListener('click', () => {
            exitImageMode();
            mode = 'text';
            resetDrawingState();
            selectedShape = null;
            selectedPoint = null;
            selectedEdge = null;
            selectedPolygonForFill = null;
            selectedLabel = null;
            labelMoveMode = false;
            selectedText = null;
            textMoveMode = false;
            selectedDistance = null;
            distanceMoveMode = false;
            selectedMeasurement = null;
            dragStart = null;
            document.getElementById('fillPatterns').style.display = 'none';
            document.getElementById('imageRotationControl').classList.add('hidden');
            updateModeButtons();
            debug('Text mode activated - click anywhere to add text labels');
            requestRedraw();
        });

        // ADDITION: Edit Text mode button
        document.getElementById('editTextBtn').addEventListener('click', () => {
            exitImageMode();
            mode = 'editText';
            resetDrawingState();
            selectedShape = null;
            selectedPoint = null;
            selectedEdge = null;
            selectedPolygonForFill = null;
            selectedLabel = null;
            labelMoveMode = false;
            selectedText = null;
            textMoveMode = false;
            selectedDistance = null;
            distanceMoveMode = false;
            selectedMeasurement = null;
            dragStart = null;
            document.getElementById('fillPatterns').style.display = 'none';
            document.getElementById('imageRotationControl').classList.add('hidden');
            updateModeButtons();
            debug('Edit Text mode activated - click on text labels to edit them');
            requestRedraw();
        });

        document.getElementById('paintBtn').addEventListener('click', () => {
            exitImageMode();
            mode = 'paint';
            resetDrawingState();
            selectedShape = null;
            selectedPoint = null;
            selectedEdge = null;
            selectedPolygonForFill = null;
            selectedLabel = null;
            labelMoveMode = false;
            selectedText = null;
            textMoveMode = false;
            selectedDistance = null;
            distanceMoveMode = false;
            selectedMeasurement = null;
            dragStart = null;
            document.getElementById('fillPatterns').style.display = 'block';
            document.getElementById('imageRotationControl').classList.add('hidden');
            updateModeButtons();
            debug('Paint mode activated - select color and click inside polygons to fill');
            requestRedraw();
        });

        // â”€â”€ Exit image-move mode cleanly â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function exitImageMode() {
            if (!imageMode) return;
            imageMode = false;
            mode = 'select';
            document.getElementById('imageRotationControl').classList.add('hidden');
            const bbMov = document.getElementById('bbMoveImage');
            if (bbMov) bbMov.classList.remove('bb-active');
            // Reset the hidden moveImageBtn text so re-entering works correctly
            const movBtn = document.getElementById('moveImageBtn');
            if (movBtn) movBtn.textContent = 'Move Image';
            updateModeButtons();
        }

        document.getElementById('moveImageBtn').addEventListener('click', () => {
            imageMode = !imageMode;
            mode = imageMode ? 'moveImage' : 'select';
            resetDrawingState();
            selectedShape = null;
            selectedPoint = null;
            selectedEdge = null;
            selectedPolygonForFill = null;
            selectedLabel = null;
            labelMoveMode = false;
            selectedText = null;
            textMoveMode = false;
            selectedDistance = null;
            distanceMoveMode = false;
            selectedMeasurement = null;
            dragStart = null;
            document.getElementById('fillPatterns').style.display = 'none';
            document.getElementById('moveImageBtn').textContent = imageMode ? 'Exit Image Mode' : 'Move Image';
            
            if (imageMode) {
                document.getElementById('imageRotationControl').classList.remove('hidden');
            } else {
                document.getElementById('imageRotationControl').classList.add('hidden');
            }
            
            updateModeButtons();
            // Sync bottom bar button state
            const bbMov2 = document.getElementById('bbMoveImage');
            if (bbMov2) bbMov2.classList.toggle('bb-active', imageMode);
            debug(imageMode ? 'Entered image move mode' : 'Exited image move mode');
            requestRedraw();
        });

        const COLOR_CYCLE = ['black', 'darkgray', 'red', 'green', 'blue', 'brown', 'gray', 'purple'];
        let colorIndex = 0;

        function updateColorBtn() {
            const c = COLOR_CYCLE[colorIndex];
            const hex = COLOR_MAP[c];
            const displayName = { darkgray: 'Dark Slate' }[c] || (c.charAt(0).toUpperCase() + c.slice(1));
            document.getElementById('colorBtn').innerHTML =
                `<span style="display:inline-block;width:10px;height:10px;background:${hex};border:1px solid #666;border-radius:2px;margin-right:4px;vertical-align:middle;"></span>Color: ${displayName}`;
        }

        function updateLineStyleBtn() {
            const labels = { thin: 'â”€ Line: Thin', medium: 'â”€ Line: Medium', thick: 'â” Line: Thick', dashed: 'â•Œ Line: Dashed' };
            document.getElementById('lineStyleBtn').textContent = labels[currentLineStyle] || 'Line: Thin';
        }

        document.getElementById('lineStyleBtn').addEventListener('click', () => {
            const cycle = ['thin','medium','thick','dashed'];
            const idx = cycle.indexOf(currentLineStyle);
            currentLineStyle = cycle[(idx + 1) % cycle.length];
            updateLineStyleBtn();
            console.log('[Style btn] selectedShapes.size=', selectedShapes.size, 'selectedShape=', selectedShape, 'newStyle=', currentLineStyle);
            // Apply line style to selected shapes
            if (selectedShapes.size > 0) {
                saveHistoryState();
                selectedShapes.forEach(s => { s.lineStyle = currentLineStyle; invalidateShapeCache(s); });
                showStatus(`âœ“ Style â†’ ${currentLineStyle} applied to ${selectedShapes.size} shape(s)`);
            } else if (selectedShape) {
                // fallback: try selectedShape directly
                saveHistoryState();
                selectedShape.lineStyle = currentLineStyle;
                invalidateShapeCache(selectedShape);
                showStatus(`âœ“ Style â†’ ${currentLineStyle} applied via selectedShape`);
            } else {
                showStatus(`âš  Nothing selected â€” selectedShapes:${selectedShapes.size} selectedShape:${!!selectedShape}`);
            }
            requestRedraw();
        });

        document.getElementById('colorBtn').addEventListener('click', () => {
            colorIndex = (colorIndex + 1) % COLOR_CYCLE.length;
            currentLineColor = COLOR_CYCLE[colorIndex];
            updateColorBtn();
            paintColor = `solid-${currentLineColor}`;
            // Apply to selected label (colour stored independently from shape)
            if (textMoveMode && selectedText) {
                saveHistoryState();
                selectedText.color = currentLineColor;
                showStatus(`âœ“ Label color â†’ ${currentLineColor}`);
            } else if (distanceMoveMode && selectedDistance && selectedDistance.shape) {
                // Change the parent shape's line colour (label will follow automatically)
                saveHistoryState();
                selectedDistance.shape.color = currentLineColor;
                invalidateShapeCache(selectedDistance.shape);
                showStatus(`âœ“ Color â†’ ${currentLineColor}`);
            } else if (labelMoveMode && selectedLabel && selectedLabel.shape) {
                // Area label: store colour on the shape's areaLabelColor â€” does NOT change the line color
                saveHistoryState();
                selectedLabel.shape.areaLabelColor = currentLineColor;
                invalidateShapeCache(selectedLabel.shape);
                showStatus(`âœ“ Area label color â†’ ${currentLineColor}`);
            // Apply to all selected shapes
            } else if (selectedShapes.size > 0) {
                saveHistoryState();
                selectedShapes.forEach(s => { s.color = currentLineColor; invalidateShapeCache(s); });
                showStatus(`âœ“ Color â†’ ${currentLineColor} applied to ${selectedShapes.size} shape(s)`);
            } else if (selectedShape) {
                saveHistoryState();
                selectedShape.color = currentLineColor;
                invalidateShapeCache(selectedShape);
                showStatus(`âœ“ Color â†’ ${currentLineColor} applied`);
            }
            requestRedraw();
        });

        document.getElementById('fillBtn').addEventListener('click', () => {
            const patternsDiv = document.getElementById('fillPatterns');
            patternsDiv.style.display = patternsDiv.style.display === 'none' ? 'block' : 'none';
        });

        document.getElementById('fillOpacitySlider').addEventListener('input', function() {
            polygonFillOpacity = parseInt(this.value) / 100;
            document.getElementById('fillOpacityLabel').textContent = this.value + '%';
            // Apply to any selected polygons immediately
            let changed = false;
            selectedShapes.forEach(s => {
                if (s.type === 'polygon') { s.fillOpacity = polygonFillOpacity; invalidateShapeCache(s); changed = true; }
            });
            if (selectedPolygonForFill) { selectedPolygonForFill.fillOpacity = polygonFillOpacity; invalidateShapeCache(selectedPolygonForFill); changed = true; }
            if (changed) requestRedraw();
        });

        document.querySelectorAll('.fill-pattern').forEach(button => {
            button.addEventListener('click', (e) => {
                const fillPattern = e.target.getAttribute('data-fill');
                
                if (mode === 'paint') {
                    paintColor = fillPattern;
                    debug(`Paint color set to: ${fillPattern}`);
                } else if (selectedPolygonForFill) {
                    saveHistoryState();
                    selectedPolygonForFill.fill = fillPattern;
                    invalidateShapeCache(selectedPolygonForFill);
                    selectedPolygonForFill = null;
                    requestRedraw();
                    debug(`Applied fill pattern: ${fillPattern}`);
                } else {
                    polygonFill = fillPattern;
                    debug(`Default fill set to: ${fillPattern}`);
                }
                
                document.getElementById('fillPatterns').style.display = 'none';
            });
        });

        document.addEventListener('keydown', (e) => {
            // Don't fire shortcuts when typing in an input
            if (e.target.matches('input, textarea')) return;

            // â”€â”€ Undo / Redo â”€â”€
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); return; }
            if (e.ctrlKey && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) { e.preventDefault(); redo(); return; }

            // â”€â”€ Debug panel toggle â”€â”€
            if (e.key === '`') {
                const d = document.getElementById('debug');
                d.style.display = d.style.display === 'none' ? 'block' : 'none';
                return;
            }

            // â”€â”€ Mode shortcuts â”€â”€
            if (!e.ctrlKey && !e.altKey) {
                const modeMap = { 'd': 'draw', 's': 'select', 'm': 'measure', 't': 'text', 'p': 'paint', 'h': 'pan' };
                if (modeMap[e.key.toLowerCase()]) {
                    e.preventDefault();
                    document.getElementById({ draw:'drawBtn', select:'selectBtn', measure:'measureBtn', text:'textBtn', paint:'paintBtn', pan:'panBtn' }[modeMap[e.key.toLowerCase()]]).click();
                    return;
                }
            }

            // â”€â”€ Arrow keys: nudge image in moveImage mode â”€â”€
            if (mode === 'moveImage' && backgroundImage &&
                (e.key === 'ArrowLeft' || e.key === 'ArrowRight' ||
                 e.key === 'ArrowUp'   || e.key === 'ArrowDown')) {
                e.preventDefault();
                // Shift = coarse (10Ã— step), plain = fine (1 world-unit)
                const step = (e.shiftKey ? 10 : 1) / zoom;
                saveHistoryState();
                if (e.key === 'ArrowLeft')  imageTransform.x -= step;
                if (e.key === 'ArrowRight') imageTransform.x += step;
                if (e.key === 'ArrowUp')    imageTransform.y -= step;
                if (e.key === 'ArrowDown')  imageTransform.y += step;
                requestRedraw();
                return;
            }

            // â”€â”€ Escape: cancel / finish current operation â”€â”€
            if (e.key === 'Escape') {
                e.preventDefault();

                if (mode === 'draw') {
                    if (points.length >= 2) {
                        saveHistoryState();
                        shapes.push({ type:'line', points:[...points], color:currentLineColor, lineStyle:currentLineStyle, layer:currentLayer });
                        const n = createPolygonsFromLines();
                        showStatus(n > 0 ? `Created ${n} polygon(s)` : 'Line saved');
                    } else if (points.length === 1) {
                        showStatus('Draw cancelled');
                    }
                    resetDrawingState();
                    requestRedraw();

                } else if (mode === 'measure') {
                    if (measurePoints.length > 0) {
                        measurePoints = [];
                        previewPoint = null;
                        currentSnapInfo = null;
                        showStatus('Measurement cancelled');
                        requestRedraw();
                    }

                } else if (mode === 'select') {
                    // Cancel any in-progress label/text/distance move
                    if (labelMoveMode || textMoveMode || distanceMoveMode) {
                        labelMoveMode = false; selectedLabel = null;
                        textMoveMode = false;  selectedText = null;
                        distanceMoveMode = false; selectedDistance = null;
                        showStatus('Move cancelled');
                        requestRedraw();
                    } else {
                        selectedShape = null; selectedPoint = null;
                        selectedEdge = null; selectedMeasurement = null;
                        selectedShapes = new Set();
                        dragStart = null;
                        requestRedraw();
                    }

                } else if (mode === 'text' || mode === 'editText' || mode === 'paint' || mode === 'moveImage') {
                    // Escape from special modes â†’ back to select
                    document.getElementById('selectBtn').click();
                }
                return;
            }

            // â”€â”€ Delete â”€â”€
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (mode === 'select') {
                    if (textMoveMode && selectedText) {
                        saveHistoryState();
                        textLabels = textLabels.filter(t => t !== selectedText);
                        selectedText = null; textMoveMode = false;
                        showStatus('Text label deleted');
                        requestRedraw();
                    } else if (selectedEdge || selectedShapes.size > 0 || selectedPoint || selectedMeasurement) {
                        saveHistoryState();
                        // Delete all shapes in the multi-select set (includes measure shapes)
                        if (selectedShapes.size > 0) {
                            selectedShapes.forEach(s => { invalidateShapeCache(s); distancePositions.delete(s); });
                            shapes = shapes.filter(s => !selectedShapes.has(s));
                            selectedShapes = new Set();
                            selectedShape = null;
                            selectedMeasurement = null;
                        } else if (selectedMeasurement) {
                            distancePositions.delete(selectedMeasurement);
                            shapes = shapes.filter(s => s !== selectedMeasurement);
                        }
                        selectedPoint = null; selectedEdge = null; selectedMeasurement = null; dragStart = null;
                        requestRedraw();
                    }
                } else if (mode === 'draw' && points.length > 0) {
                    points.pop(); previewPoint = null; bisectionTarget = checkForBisection(); requestRedraw();
                } else if (mode === 'measure' && measurePoints.length > 0) {
                    measurePoints.pop(); previewPoint = null; requestRedraw();
                }
            }
        });

        canvas.addEventListener('click', (e) => {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const canvasPoint = safeToCanvasCoords(e.clientX - rect.left, e.clientY - rect.top);
            let x = canvasPoint.x;
            let y = canvasPoint.y;

            const snapResult = findBestSnapPoint(x, y);
            if (snapResult && (mode === 'draw' || mode === 'measure')) {
                x = snapResult.x;
                y = snapResult.y;
            }

            switch(mode) {
                case 'pan': break;
                case 'draw':
                    handleDrawClick(x, y, snapResult);
                    break;
                case 'select':
                    handleSelectClick(x, y, e.ctrlKey || e.metaKey);
                    break;
                case 'measure':
                    handleMeasureClick(x, y);
                    break;
                case 'paint':
                    handlePaintClick(x, y);
                    break;
                case 'text':
                    handleTextClick(x, y);
                    break;
                case 'editText':
                    handleEditTextClick(x, y);
                    break;
                case 'moveImage':
                    // Drag is handled by mousedown/mousemove/mouseup â€” nothing to do on click
                    break;
            }
            
            requestRedraw();
        });

        // Double-click event handler - only for drawing mode
        canvas.addEventListener('dblclick', (e) => {
            e.preventDefault();
            
            if (mode === 'draw' && points.length > 1) {
                // The second click of the dblclick already added a duplicate endpoint â€” remove it
                points.pop();
                
                if (points.length < 2) {
                    requestRedraw();
                    return;
                }
                
                // Check for bisection first
                if (bisectionTarget && points.length >= 2) {
                    saveHistoryState();
                    if (executeBisection(bisectionTarget)) {
                        resetDrawingState();
                        requestRedraw();
                        return;
                    }
                }
                
                // Save current line and try to form polygons
                saveHistoryState();
                shapes.push({ 
                    type: 'line', 
                    points: [...points], 
                    color: currentLineColor,
                    lineStyle: currentLineStyle,
                    layer: currentLayer
                });
                debug(`Saved line with ${points.length} points`);
                
                // Try to create polygons from all existing lines
                const polygonsCreated = createPolygonsFromLines();
                
                if (polygonsCreated > 0) {
                    debug(`Double-click created ${polygonsCreated} polygons`);
                    showStatus(`Created ${polygonsCreated} polygon(s) from connected lines`);
                } else {
                    debug('Line saved via double-click, no polygons formed');
                }
                
                resetDrawingState();
                requestRedraw();
            }
        });

        // Pan state
        let isPanning = false;
        let panStart = null;
        let spaceHeld = false;
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !e.target.matches('input, textarea')) {
                spaceHeld = true;
                canvas.style.cursor = 'grab';
                e.preventDefault();
            }
        }, true);
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spaceHeld = false;
                canvas.style.cursor = '';
            }
        });
        
        // Image drag-and-drop on the sidebar drop zone
        const _imgDZ = document.getElementById('imgDropZone');
        if (_imgDZ) {
            _imgDZ.addEventListener('dragover', e => { e.preventDefault(); _imgDZ.classList.add('dragover'); });
            _imgDZ.addEventListener('dragleave', () => _imgDZ.classList.remove('dragover'));
            _imgDZ.addEventListener('drop', e => {
                e.preventDefault(); _imgDZ.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    document.getElementById('imageUpload').files = e.dataTransfer.files;
                    document.getElementById('imageUpload').dispatchEvent(new Event('change'));
                }
            });
        }


        // Open settings collapsible by default
        (function() {
            const b = document.getElementById('settingsBody');
            if (b) { b.style.maxHeight = b.scrollHeight + 200 + 'px'; b.style.overflow = 'visible'; }
            const arr = document.querySelector('.collapsible-label .collapsible-arrow');
            if (arr) arr.classList.add('open');
        })();


        canvas.addEventListener('mousedown', (e) => {
            if (mode === 'moveImage' && backgroundImage && e.button === 0) {
                saveHistoryState();
                imageDragActive = true;
                const rect = canvas.getBoundingClientRect();
                const cx = e.clientX - rect.left;
                const cy = e.clientY - rect.top;
                imageDragStart = { mouseX: cx, mouseY: cy, imgX: imageTransform.x, imgY: imageTransform.y };
                e.preventDefault();
                return;
            }
            if (e.button === 1 || (e.button === 0 && spaceHeld) || (e.button === 0 && mode === 'pan')) {
                // Middle button or Space+left = pan
                e.preventDefault();
                isPanning = true;
                panStart = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (imageDragActive && imageDragStart) {
                const rect = canvas.getBoundingClientRect();
                const cx = e.clientX - rect.left;
                const cy = e.clientY - rect.top;
                // Convert screen delta to canvas coords
                const dx = (cx - imageDragStart.mouseX) / zoom;
                const dy = (cy - imageDragStart.mouseY) / zoom;
                imageTransform.x = imageDragStart.imgX + dx;
                imageTransform.y = imageDragStart.imgY + dy;
                requestRedraw();
                return;
            }
            if (isPanning && panStart) {
                offsetX += e.clientX - panStart.x;
                offsetY += e.clientY - panStart.y;
                panStart = { x: e.clientX, y: e.clientY };
                requestRedraw();
                return; // Don't run normal mousemove logic while panning
            }
            const rect = canvas.getBoundingClientRect();
            const canvasPoint = safeToCanvasCoords(e.clientX - rect.left, e.clientY - rect.top);
            previewPoint = { x: canvasPoint.x, y: canvasPoint.y };

            if (mode === 'draw' || mode === 'measure') {
                const snapResult = findBestSnapPoint(previewPoint.x, previewPoint.y);
                if (snapResult) {
                    previewPoint.x = snapResult.x;
                    previewPoint.y = snapResult.y;
                }
            }

            if (mode === 'select') {
                handleSelectMouseMove(previewPoint.x, previewPoint.y);
            }

            updateDrawCounter();
            requestRedraw();
        });

        canvas.addEventListener('mouseup', (e) => {
            if (imageDragActive) {
                imageDragActive = false;
                imageDragStart = null;
                return;
            }
            if (isPanning) {
                isPanning = false;
                panStart = null;
                canvas.style.cursor = spaceHeld ? 'grab' : (mode === 'pan' ? 'grab' : '');
                return;
            }
            if (mode === 'select') {
                dragStart = null;
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            // Scroll always zooms the canvas view â€” never scales the background image.
            // (Image scale can be adjusted by dragging handles in Move Image mode.)
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const oldZoom = zoom;
            zoom *= e.deltaY > 0 ? 0.9 : 1.1;
            zoom = Math.max(0.1, Math.min(zoom, 100));
            offsetX = mouseX - (mouseX - offsetX) * (zoom / oldZoom);
            offsetY = mouseY - (mouseY - offsetY) * (zoom / oldZoom);
            debug(`Zoom: ${zoom.toFixed(2)}x, Snap distance: ${getSnapDistance().toFixed(1)}px`);
            requestRedraw();
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            // Right-click cancels the current in-progress operation (like Escape) rather
            // than destroying the whole canvas (which was too easy to trigger accidentally).
            if (mode === 'draw' && points.length > 0) {
                resetDrawingState();
                showStatus('Draw cancelled');
                requestRedraw();
            } else if (mode === 'measure' && measurePoints.length > 0) {
                measurePoints = [];
                previewPoint = null;
                currentSnapInfo = null;
                showStatus('Measurement cancelled');
                requestRedraw();
            } else if (labelMoveMode || textMoveMode || distanceMoveMode) {
                labelMoveMode = false; selectedLabel = null;
                textMoveMode = false;  selectedText = null;
                distanceMoveMode = false; selectedDistance = null;
                showStatus('Move cancelled');
                requestRedraw();
            }
            // (If nothing is in progress, right-click does nothing - use the Clear button)
        });

        function handleCanvasResize() {
            try {
                const container = document.getElementById('canvas-container');
                const newWidth = container.clientWidth - 2;
                const newHeight = container.clientHeight - 2;
                
                if (newWidth > 0 && newHeight > 0) {
                    canvas.width = newWidth;
                    canvas.height = newHeight;
                    requestRedraw();
                }
            } catch (error) {
                console.error('Error resizing canvas:', error);
            }
        }

        if (window.ResizeObserver) {
            const resizeObserver = new ResizeObserver(handleCanvasResize);
            resizeObserver.observe(document.getElementById('canvas-container'));
        }

        // â”€â”€ Save / Open / Autosave â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const AUTOSAVE_KEY   = 'lotdesigner_autosave';
        const AUTOSAVE_DELAY = 5000; // ms after last change before writing localStorage
        let autosaveTimer    = null;
        let currentFileName  = null; // tracks last-saved file name for Ctrl+S re-save

        // â”€â”€ Serialise full drawing state â”€â”€
        function serializeDrawing() {
            // Stamp IDs on all shapes FIRST so the serialized shapes array contains
            // the same IDs that serializeMap will reference for position lookups.
            shapes.forEach(s => ensureShapeId(s));

            function serializeMap(map) {
                const entries = [];
                map.forEach((value, key) => {
                    const k = (typeof key === 'string') ? key : `__shape_${ensureShapeId(key)}`;
                    entries.push([k, value]);
                });
                return entries;
            }

            return {
                version: 2,
                savedAt: new Date().toISOString(),
                viewport: { zoom, offsetX, offsetY },
                settings: {
                    scale,
                    useMetricUnits,
                    currentLineColor,
                    currentLineStyle,
                    polygonFill,
                    enable90DegSnaps,
                    enablePerpSnap,
                    currentLayer,
                    imageOpacity,
                    colorIndex
                },
                imageTransform,
                // Background image: stored as base64 data-URL so file is self-contained.
                // Omit if null; warn if very large.
                backgroundImageSrc: (backgroundImage && backgroundImage.src &&
                                     backgroundImage.src.startsWith('data:')) ? backgroundImage.src : null,
                shapes: JSON.parse(JSON.stringify(shapes)),
                textLabels: JSON.parse(JSON.stringify(textLabels)),
                labelPositions: serializeMap(labelPositions),
                distancePositions: serializeMap(distancePositions),
                labelColors: serializeMap(labelColors)
            };
        }

        // â”€â”€ Deserialise and restore â”€â”€
        function deserializeDrawing(data) {
            if (!data || data.version < 1) throw new Error('Unrecognised file format');

            // Viewport
            if (data.viewport) {
                zoom    = data.viewport.zoom    || 1;
                offsetX = data.viewport.offsetX || 0;
                offsetY = data.viewport.offsetY || 0;
            }

            // Settings
            if (data.settings) {
                const s = data.settings;
                scale             = s.scale             ?? 1;
                useMetricUnits    = s.useMetricUnits     ?? false;
                currentLineColor  = s.currentLineColor   ?? 'black';
                currentLineStyle  = s.currentLineStyle   ?? 'thin';
                polygonFill       = s.polygonFill        ?? 'none';
                enable90DegSnaps  = s.enable90DegSnaps   ?? true;
                enablePerpSnap    = s.enablePerpSnap     ?? true;
                currentLayer      = s.currentLayer       ?? 'boundary';
                imageOpacity      = s.imageOpacity       ?? 0.5;
                colorIndex        = COLOR_CYCLE.indexOf(currentLineColor);
                if (colorIndex < 0) colorIndex = 0;
            }

            // Image transform
            if (data.imageTransform) {
                imageTransform = data.imageTransform;
            }

            // Shapes and labels
            shapes     = data.shapes     ? JSON.parse(JSON.stringify(data.shapes))     : [];
            textLabels = data.textLabels ? JSON.parse(JSON.stringify(data.textLabels)) : [];

            // Rebuild label position Maps
            // Shape-id-keyed entries (e.g. "__shape_3") need to be re-matched to loaded shape objects
            // We build a lookup: shapeId â†’ shape object (shapes get IDs stamped on first ensureShapeId call)
            // For simplicity, pre-stamp IDs on all loaded shapes now
            shapes.forEach(s => { if (!s.id) s.id = newShapeId(); });
            const shapeById = {};
            shapes.forEach(s => { shapeById[s.id] = s; });

            labelPositions    = new Map();
            distancePositions = new Map();
            labelColors       = new Map();

            function restoreMap(entries, targetMap) {
                if (!Array.isArray(entries)) return;
                entries.forEach(([k, v]) => {
                    if (typeof k === 'string' && k.startsWith('__shape_')) {
                        const id = parseInt(k.replace('__shape_', ''));
                        const shapeObj = shapeById[id];
                        if (shapeObj) targetMap.set(shapeObj, v);
                    } else {
                        targetMap.set(k, v);
                    }
                });
            }
            restoreMap(data.labelPositions,    labelPositions);
            restoreMap(data.distancePositions, distancePositions);
            if (data.labelColors) restoreMap(data.labelColors, labelColors);

            // Background image (async â€” reload from base64 if present)
            backgroundImage = null;
            showImage       = false;
            if (data.backgroundImageSrc) {
                const img = new Image();
                img.onload = () => { backgroundImage = img; showImage = true; requestRedraw(); };
                img.src = data.backgroundImageSrc;
            }

            // Sync UI controls
            document.getElementById('scale').value = scale;
            document.getElementById('unitsBtn').textContent = `Units: ${useMetricUnits ? 'Metric' : 'Imperial'}`;
            document.getElementById('unitLabel').textContent = getDistanceUnit();
            document.getElementById('toggleSnaps').textContent = `90Â° Snaps: ${enable90DegSnaps ? 'ON' : 'OFF'}`;
            document.getElementById('perpSnapBtn').textContent = `âŠ¥ Perp Snap: ${enablePerpSnap ? 'ON' : 'OFF'}`;
            document.getElementById('transparency').value = imageOpacity;
            updateColorBtn();
            updateLineStyleBtn();
            updateLayerBtn();
            if (typeof syncBottomBar === 'function') syncBottomBar();

            shapeCache.clear();
            hatchPatternCache.clear();
            history      = [];
            historyIndex = -1;
            saveHistoryState();
            updateModeButtons();
            requestRedraw();
        }

        // â”€â”€ Download as .lot file â”€â”€
        function saveDrawing(promptName = false) {
            const data = serializeDrawing();
            const json = JSON.stringify(data, null, 2);

            const now    = new Date();
            const stamp  = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
            const suggestName = currentFileName || `lot-drawing-${stamp}.lot`;

            // Try standard download first
            try {
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(json);
                const a = document.createElement('a');
                a.href = dataUri;
                a.download = suggestName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            } catch(e) {}

            // Also copy to clipboard and show a save dialog as fallback
            // (needed when running inside an iframe that blocks downloads)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(json).then(() => {
                    showSaveDialog(json, suggestName, true);
                }).catch(() => {
                    showSaveDialog(json, suggestName, false);
                });
            } else {
                showSaveDialog(json, suggestName, false);
            }

            currentFileName = suggestName;
            setAutosaveIndicator(`Saved ${suggestName}`);
        }

        function showSaveDialog(json, filename, copied) {
            // Remove any existing dialog
            const existing = document.getElementById('saveDialog');
            if (existing) existing.remove();

            const overlay = document.createElement('div');
            overlay.id = 'saveDialog';
            overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.6);z-index:9999;display:flex;align-items:center;justify-content:center;';

            overlay.innerHTML = `
                <div style="background:#fff;border-radius:8px;padding:20px;width:520px;max-width:90vw;box-shadow:0 4px 24px rgba(0,0,0,0.4);">
                    <h3 style="margin:0 0 8px 0;font-size:14px;">ğŸ’¾ Save Drawing â€” ${filename}</h3>
                    <p style="margin:0 0 10px 0;font-size:12px;color:#555;">
                        ${copied ? 'âœ… JSON copied to clipboard!' : 'âš ï¸ Copy the text below and save as <b>' + filename + '</b>'}
                        ${copied ? ' Paste into a <b>.lot</b> file to save.' : ''}
                    </p>
                    <textarea id="saveJsonArea" readonly style="width:100%;height:160px;font-family:monospace;font-size:10px;border:1px solid #ccc;border-radius:4px;padding:6px;box-sizing:border-box;resize:vertical;">${json.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</textarea>
                    <div style="display:flex;gap:8px;margin-top:10px;">
                        <button id="saveCopyBtn" style="flex:1;padding:8px;background:#0055ff;color:#fff;border:none;border-radius:4px;cursor:pointer;font-weight:bold;">ğŸ“‹ Copy to Clipboard</button>
                        <button id="saveCloseBtn" style="flex:1;padding:8px;background:#555;color:#fff;border:none;border-radius:4px;cursor:pointer;">Close</button>
                    </div>
                    <p style="margin:8px 0 0 0;font-size:11px;color:#888;">To reload: use the Open button and select your saved .lot file (or paste the JSON into any .lot file).</p>
                </div>`;

            document.body.appendChild(overlay);

            document.getElementById('saveCopyBtn').onclick = () => {
                const ta = document.getElementById('saveJsonArea');
                ta.select();
                try { navigator.clipboard.writeText(json); } catch(e) { document.execCommand('copy'); }
                document.getElementById('saveCopyBtn').textContent = 'âœ… Copied!';
            };
            document.getElementById('saveCloseBtn').onclick = () => overlay.remove();
            overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };
        }

        // â”€â”€ Load from .lot file â”€â”€
        function openDrawing(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    deserializeDrawing(data);
                    currentFileName = file.name;
                    setAutosaveIndicator(`Loaded ${file.name}`);
                    showStatus(`Opened: ${file.name}`);
                } catch (err) {
                    showStatus(`Error opening file: ${err.message}`);
                    console.error('Open failed:', err);
                }
            };
            reader.readAsText(file);
        }

        // â”€â”€ Autosave to localStorage â”€â”€
        function scheduleAutosave() {
            clearTimeout(autosaveTimer);
            autosaveTimer = setTimeout(() => {
                try {
                    const json = JSON.stringify(serializeDrawing());
                    // Skip if > 8 MB (background image makes it huge; just skip rather than fail)
                    if (json.length > 8 * 1024 * 1024) {
                        setAutosaveIndicator('Autosave skipped (image too large)');
                        return;
                    }
                    localStorage.setItem(AUTOSAVE_KEY, json);
                    const t = new Date().toLocaleTimeString([], { hour:'2-digit', minute:'2-digit' });
                    setAutosaveIndicator(`Autosaved ${t}`);
                } catch(err) {
                    setAutosaveIndicator('Autosave failed');
                }
            }, AUTOSAVE_DELAY);
        }

        function setAutosaveIndicator(msg) {
            document.getElementById('autosaveIndicator').textContent = msg;
            const bb = document.getElementById('bbAutosave');
            if (bb) bb.textContent = msg;
        }

        // â”€â”€ Restore autosave on page load â”€â”€
        function tryRestoreAutosave() {
            try {
                const json = localStorage.getItem(AUTOSAVE_KEY);
                if (!json) return;
                const data = JSON.parse(json);
                if (!data || !data.savedAt) return;
                const when = new Date(data.savedAt).toLocaleString([], {
                    month:'short', day:'numeric', hour:'2-digit', minute:'2-digit'
                });
                const shapeCount = (data.shapes || []).length;
                if (shapeCount === 0) return;

                // Build a simple Yes/No overlay (no text input needed)
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:fixed;inset:0;z-index:3000;display:flex;align-items:center;justify-content:center;background:rgba(20,35,55,0.6);font-family:"Inter",Arial,sans-serif;';
                overlay.innerHTML = `
                    <div style="background:#fff;border:1px solid #b8c0ca;border-radius:8px;padding:22px 26px;min-width:320px;max-width:420px;box-shadow:0 8px 40px rgba(0,0,0,0.3);">
                        <div style="font-size:13px;font-weight:600;color:#1e4a80;margin-bottom:8px;">Restore Autosaved Drawing?</div>
                        <div style="font-size:12px;color:#3d4f66;margin-bottom:18px;line-height:1.5;">
                            Found a drawing autosaved at <strong>${when}</strong><br>
                            (${shapeCount} shape${shapeCount!==1?'s':''}). Restore it?
                        </div>
                        <div style="display:flex;gap:10px;justify-content:flex-end;">
                            <button id="_restoreNo" style="padding:7px 18px;font-size:12px;background:#e4e8ed;color:#3d4f66;border:1px solid #b8c0ca;border-radius:3px;cursor:pointer;">No, start fresh</button>
                            <button id="_restoreYes" style="padding:7px 18px;font-size:12px;background:#1a5fa0;color:#fff;border:1px solid #4a90d0;border-radius:3px;cursor:pointer;font-weight:600;">Yes, restore</button>
                        </div>
                    </div>`;
                document.body.appendChild(overlay);
                overlay.querySelector('#_restoreYes').addEventListener('click', () => {
                    document.body.removeChild(overlay);
                    deserializeDrawing(data);
                    setAutosaveIndicator(`Restored from ${when}`);
                    showStatus('Autosaved drawing restored');
                });
                overlay.querySelector('#_restoreNo').addEventListener('click', () => {
                    document.body.removeChild(overlay);
                });
            } catch(e) {
                console.warn('Autosave restore failed:', e);
            }
        }


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // WORKFLOW STEP SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let currentWorkflowStep = 1;

        function workflowStep(n) {
            currentWorkflowStep = n;
            exitImageMode(); // always exit image mode when switching steps

            // Update step buttons
            for (let i = 1; i <= 3; i++) {
                const btn = document.getElementById('wfStep' + i);
                if (btn) btn.classList.toggle('wf-active', i === n);
            }

            // Show/hide sidebar sections with data-steps attribute
            document.querySelectorAll('#toolbar [data-steps]').forEach(el => {
                const steps = el.getAttribute('data-steps').split(',').map(s => parseInt(s.trim()));
                el.style.display = steps.includes(n) ? '' : 'none';
            });

            // Always show the tools section
            const toolSection = document.querySelector('#toolbar .tb-section');
            if (toolSection) toolSection.style.display = '';

            // Switch to sensible default mode for the step
            if (n === 1) {
                if (mode !== 'moveImage') { mode = 'select'; updateModeButtons(); }
            } else if (n === 2) {
                mode = 'draw'; updateModeButtons();
                currentLayer = 'boundary'; updateLayerBtn();
                // Boundary defaults: medium black line, no fill
                currentLineStyle = 'medium'; updateLineStyleBtn();
                colorIndex = COLOR_CYCLE.indexOf('black'); currentLineColor = 'black'; updateColorBtn();
                polygonFill = 'none';
                document.getElementById('fillPatterns').style.display = 'none';
            } else if (n === 3) {
                if (mode === 'moveImage') { mode = 'draw'; updateModeButtons(); }
                else if (mode === 'select') { /* keep select */ }
                else { mode = 'draw'; updateModeButtons(); }
                currentLayer = 'feature'; updateLayerBtn();
                // Feature defaults: thin dark-gray line, light gray fill
                currentLineStyle = 'thin'; updateLineStyleBtn();
                colorIndex = COLOR_CYCLE.indexOf('darkgray'); currentLineColor = 'darkgray'; updateColorBtn();
                polygonFill = 'hatch-darkgray';
                document.getElementById('fillPatterns').style.display = 'none';
            }
        }

        // Initial call to set up step 1
        workflowStep(1);

        // â”€â”€ Skip/Next button in step 1 â”€â”€
        document.getElementById('skipToDrawBtn').addEventListener('click', () => workflowStep(2));

        // â”€â”€ Sidebar scale input (step 2) â€” linked to bbScale â”€â”€
        document.getElementById('sidebarScale').addEventListener('input', function() {
            scale = parseFloat(this.value) || 1;
            document.getElementById('scale').value = scale;
            document.getElementById('bbScale').value = this.value;
            shapeCache.clear();
            requestRedraw();
        });
        document.getElementById('sidebarUnitsBtn').addEventListener('click', () => {
            document.getElementById('unitsBtn').click();
            syncSidebarScaleUI();
        });

        function syncSidebarScaleUI() {
            const s = document.getElementById('sidebarScale');
            const u = document.getElementById('sidebarUnitLabel');
            const b = document.getElementById('sidebarUnitsBtn');
            if (s) s.value = scale;
            if (u) u.textContent = getDistanceUnit();
            if (b) b.textContent = `Units: ${useMetricUnits ? 'Metric' : 'Imperial'}`;
        }

        // â”€â”€ Save/Export dropdown â”€â”€
        function toggleSaveMenu() {
            const m = document.getElementById('saveExportMenu');
            m.style.display = m.style.display === 'none' ? 'block' : 'none';
        }
        function closeSaveMenu() {
            const m = document.getElementById('saveExportMenu');
            if (m) m.style.display = 'none';
        }
        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            const wrap = document.getElementById('saveExportWrapper');
            if (wrap && !wrap.contains(e.target)) closeSaveMenu();
        });

        // â”€â”€ Open button â”€â”€
        document.getElementById('bbOpenBtn2').addEventListener('click', () => {
            document.getElementById('bbOpenFileInput').click();
        });
        document.getElementById('bbOpenFileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) openDrawing(file);
            e.target.value = '';
        });
        // â”€â”€ Wire up bottom bar buttons â”€â”€
        document.getElementById('bbUndoBtn').addEventListener('click', undo);
        document.getElementById('bbRedoBtn').addEventListener('click', redo);
        document.getElementById('bbFitBtn').addEventListener('click', () => zoomToFit());
        document.getElementById('bbToggleImage').addEventListener('click', () => {
            document.getElementById('toggleImage').click();
        });
        document.getElementById('bbTransparency').addEventListener('input', function() {
            imageOpacity = parseFloat(this.value);
            document.getElementById('transparency').value = this.value;
            // Sync sidebar opacity
            const st = document.getElementById('sidebarTransparency');
            if (st) { st.value = this.value; }
            const sl = document.getElementById('sidebarOpacityLabel');
            if (sl) sl.textContent = Math.round(parseFloat(this.value) * 100) + '%';
            requestRedraw();
        });
        // Sidebar opacity slider (step 1)
        document.getElementById('sidebarTransparency').addEventListener('input', function() {
            imageOpacity = parseFloat(this.value);
            document.getElementById('transparency').value = this.value;
            document.getElementById('bbTransparency').value = this.value;
            const sl = document.getElementById('sidebarOpacityLabel');
            if (sl) sl.textContent = Math.round(parseFloat(this.value) * 100) + '%';
            requestRedraw();
        });
        document.getElementById('bbMoveImage').addEventListener('click', () => {
            if (imageMode) {
                exitImageMode();
            } else {
                document.getElementById('moveImageBtn').click();
            }
            document.getElementById('bbMoveImage').classList.toggle('bb-active', imageMode);
        });
        document.getElementById('bbScale').addEventListener('input', function() {
            scale = parseFloat(this.value) || 1;
            document.getElementById('scale').value = scale;
            const ss = document.getElementById('sidebarScale');
            if (ss) ss.value = scale;
            shapeCache.clear();
            requestRedraw();
        });
        document.getElementById('bbUnitsBtn').addEventListener('click', () => {
            document.getElementById('unitsBtn').click();
            document.getElementById('bbUnitsBtn').textContent = `Units: ${useMetricUnits ? 'Metric' : 'Imperial'}`;
            document.getElementById('bbScale').nextElementSibling && null; // keep label in sync
        });
        document.getElementById('bbClearBtn').addEventListener('click', () => {
            document.getElementById('clearBtn').click();
        });

        // Keep bbScale in sync with any programmatic scale changes
        function syncBottomBar() {
            document.getElementById('bbScale').value = scale;
            document.getElementById('bbUnitsBtn').textContent = `Units: ${useMetricUnits ? 'Metric' : 'Imperial'}`;
            document.getElementById('bbTransparency').value = imageOpacity;
            if (typeof syncSidebarScaleUI === 'function') syncSidebarScaleUI();
        }

        // syncBottomBar syncs bb controls with current state

        // â”€â”€ Wire up original hidden buttons and keyboard shortcuts â”€â”€
        document.getElementById('saveBtn').addEventListener('click', () => saveDrawing());
        document.getElementById('openBtn').addEventListener('click', () => {
            document.getElementById('openFileInput').click();
        });
        document.getElementById('openFileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) openDrawing(file);
            e.target.value = ''; // reset so same file can be re-opened
        });

        // Ctrl+S / Ctrl+O keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 's') { e.preventDefault(); saveDrawing(); }
            if (e.ctrlKey && e.key === 'o') { e.preventDefault(); document.getElementById('bbOpenFileInput').click(); }
        });
        saveHistoryState();
        updateModeButtons();
        updateColorBtn();
        updateLineStyleBtn();
        updateLayerBtn();
        syncBottomBar();
        syncSidebarScaleUI();
        redrawCanvas();
        // Offer to restore autosave after a brief delay (let canvas render first)
                setTimeout(tryRestoreAutosave, 400);
    </script>
</body>
</html>